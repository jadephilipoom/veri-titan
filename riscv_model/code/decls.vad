include{: verbatim} "../code/vale.dfy"
include{: verbatim} "../spec/rsa_ops.dfy"

#verbatim
module rv_decls {
import opened bv_ops
import opened rv_ops
import opened rsa_ops
import opened rv_consts
import opened rv_vale
#endverbatim

type seq(a: Type(0)): Type(0) {: primitive} extern;
function operator([]) #[a: Type(0)](s: seq(a), i: int): a extern; 
function operator([ := ]) #[a: Type(0)](s: seq(a), i: int, v: a): seq(a) extern;
function operator([ .. ]) #[a: Type(0)](s: seq(a), begin: int, end: int): seq(a) extern;
function seq_len #[a: Type(0)] (s: seq(a)): nat extern;
function seq_concat #[a: Type(0)](x: seq(a), y: seq(a)): seq(a) extern;
function seq_append #[a: Type(0)](xs: seq(a), x: a): seq(a) extern;

type map(a: Type(0), b: Type(0)): Type(0) extern;
function operator(?[]) #[a:Type(0), b:Type(0)](m:map(a, b), rsa:a):bool extern;
function operator([]) #[a: Type(0), b: Type(0)](m: map(a, b), rsa: a): b extern;
function operator([ := ]) #[a: Type(0), b: Type(0)](m: map(a, b), rsa: a, v: b): map(a, b) extern;

type nat:     Type(0) := int_range(0, _);
type uint1:   Type(0) := int_range(0, 1);
type uint2:   Type(0) := int_range(0, 3);
type uint5:   Type(0) := int_range(0, 31);
type uint32:  Type(0) := int_range(0, 0xffffffff);
type uint64:  Type(0) := int_range(0, 0xffffffff_ffffffff);
type uint128: Type(0) := int_range(0, 0xffffffff_ffffffff_ffffffff_ffffffff);
type uint256: Type(0) := int_range(0, 0xffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff);

function power(b: int, e: nat) : int extern;
function cong(a: int, b: int, n: int) : bool extern;

const BASE_32:  nat extern;
const BASE_64:  nat extern; 
const BASE_128: nat extern; 
const BASE_256: nat extern;
const BASE_512: nat extern;
const NUM_WORDS:nat extern;

type state: Type(0) {: primitive} extern;
function operator(.ok) (s: state): bool extern;
function operator(.ok :=) (s: state, b: bool): state extern;

type reg32_t: Type(0) extern;

type mem_t: Type(0) := map(int, seq(uint32));
    
function mem_base_addr_valid(wmem: mem_t, ptr: int, size: nat): bool extern;

type gprs_t: Type(0) extern;
function operator([]) (s: gprs_t, i: int): uint32 extern; 
function operator([ := ]) (s: gprs_t, i: int, v: uint32): gprs_t extern;
function operator([ .. ]) (s: gprs_t, begin: int, end: int): seq(uint32) extern;

function Loop(u: uint32) : bool extern;
function LoopImm(u: uint32) : bool extern;

function fst #[a: Type(0), b: Type(0)](m: tuple(a, b)): a extern;
function snd #[a: Type(0), b: Type(0)](m: tuple(a, b)): b extern;

function bool_to_uint1(i:bool) : uint1 extern;

var gprs: gprs_t {:state gprs()};

var ok: bool {:state ok()};
    
var mem: mem_t {:state mem()};
function mem_addr_valid(h: mem_t, ptr: int): bool extern;

type uint64_view_t: Type(0) extern;
function uint64_cons(lh: uint32, uh: uint32, full: uint64) : uint64_view_t extern;
function valid_uint64_view(view: uint64_view_t, lh: uint32, uh: uint32) : bool extern;

type iter_t: Type(0) extern;
function iter_inv(iter: iter_t, h: mem_t, ptr: int): bool extern;
function iter_safe(iter: iter_t, h: mem_t, ptr: int): bool extern;
    
function iter_cons(base_addr: int, index: nat, buff: seq(uint32)): iter_t extern;
function lw_next_iter(iter: iter_t): iter_t extern;
function sw_next_iter(iter: iter_t, value: uint32): iter_t extern;
function operator(.base_addr) (iter :iter_t): int extern;
function operator(.index) (iter :iter_t): int extern;
function operator(.index := ) (iter: iter_t, i :int): iter_t extern;
function operator(.buff) (iter :iter_t): seq(uint32) extern;
function operator(.buff := ) (iter :iter_t, buff: seq(uint32)): iter_t extern;

function to_nat(s: seq(uint32)): nat extern;
ghost procedure to_nat_lemma_1(ghost xs: seq(uint32)) extern;
 
type string: Type(0) extern;

var x0: uint32 {:state reg32_t(GPR(0))};
var x1: uint32 {:state reg32_t(GPR(1))};
var x2: uint32 {:state reg32_t(GPR(2))};
var x3: uint32 {:state reg32_t(GPR(3))};
var x4: uint32 {:state reg32_t(GPR(4))};
var x5: uint32 {:state reg32_t(GPR(5))};
var x6: uint32 {:state reg32_t(GPR(6))};
var x7: uint32 {:state reg32_t(GPR(7))};
var x8: uint32 {:state reg32_t(GPR(8))};
var x9: uint32 {:state reg32_t(GPR(9))};
var x10: uint32 {:state reg32_t(GPR(10))};
var x11: uint32 {:state reg32_t(GPR(11))};
var x12: uint32 {:state reg32_t(GPR(12))};
var x13: uint32 {:state reg32_t(GPR(13))};
var x14: uint32 {:state reg32_t(GPR(14))};
var x15: uint32 {:state reg32_t(GPR(15))};
var x16: uint32 {:state reg32_t(GPR(16))};
var x17: uint32 {:state reg32_t(GPR(17))};
var x18: uint32 {:state reg32_t(GPR(18))};
var x19: uint32 {:state reg32_t(GPR(19))};
var x20: uint32 {:state reg32_t(GPR(20))};
var x21: uint32 {:state reg32_t(GPR(21))};
var x22: uint32 {:state reg32_t(GPR(22))};
var x23: uint32 {:state reg32_t(GPR(23))};
var x24: uint32 {:state reg32_t(GPR(24))};
var x25: uint32 {:state reg32_t(GPR(25))};
var x26: uint32 {:state reg32_t(GPR(26))};
var x27: uint32 {:state reg32_t(GPR(27))};
var x28: uint32 {:state reg32_t(GPR(28))};
var x29: uint32 {:state reg32_t(GPR(29))};
var x30: uint32 {:state reg32_t(GPR(30))};
var x31: uint32 {:state reg32_t(GPR(31))};

operand_type reg32: uint32 @ reg32_t :=
| inout x0 | inout x1 | inout x2 | inout x3
| inout x4 | inout x5 | inout x6 | inout x7
| inout x8 | inout x9 | inout x10 | inout x11
| inout x12 | inout x13 | inout x14 | inout x15
| inout x16 | inout x17 | inout x18 | inout x19
| inout x20 | inout x21 | inout x22 | inout x23
| inout x24 | inout x25 | inout x26 | inout x27
| inout x28 | inout x29 | inout x30 | inout x31;

operand_type imm128: uint128 := const;
operand_type imm32: uint32 := const;
operand_type imm2: uint2 := const;

function uint32_lt(x: uint32, y: uint32): uint32 extern;
    
function uint32_add(x: uint32, y: uint32): uint32 extern;
function uint32_xor(x: uint32, y: uint32): uint32 extern;
function uint32_or(x: uint32, y: uint32): uint32 extern;
function uint32_and(x: uint32, y: uint32): uint32 extern;
function uint32_mul(x: uint32, y: uint32): uint32 extern;
function uint32_mulhu(x: uint32, y: uint32): uint32 extern;
function uint32_not(x: uint32): uint32 extern;
function uint32_ls(x: uint32, amount: uint32): uint32 extern;
function uint32_rs(x: uint32, y: uint32): uint32 extern;
function uint32_arith_rs(x: uint32, y: uint32): uint32 extern;
function uint32_mul(x: uint32, y: uint32): uint32 extern;
function uint32_mulhu(x: uint32, y: uint32): uint32 extern;


// --------------------------------------------------------------
// Base Integer Instructions
// --------------------------------------------------------------
    
// load instructions
    
procedure lw(inout dst: reg32, in src1: reg32, in src2: imm32, ghost iter: iter_t)
    {:instruction Ins32(RV_LW(dst, src1, src2))}
    reads
        mem;
    requires
        src2 < 0x1000; // 12-bit
        iter_safe(iter, mem, src1 + src2);
    ensures
        // mem location = src + sign-extended immediate
        dst == old(mem[iter.base_addr][iter.index]);
{
    assume false;
}

procedure lw_safe(inout dst: reg32, in src1: reg32, in src2: imm32, ghost iter: iter_t)
    returns (ghost next_iter: iter_t)
    reads
        mem;
    requires
        src2 < 0x1000; // 12-bit
        iter_safe(iter, mem, src1 + src2);
    ensures
        // mem location = src + sign-extended immediate
        dst == old(mem[iter.base_addr][iter.index]);
        iter_inv(next_iter, mem, old(src1) + old(src2) + 4);
        next_iter == lw_next_iter(iter);
{
    next_iter := iter.(index := iter.index + 1);
    lw(dst, src1, src2, iter);
}

// procedure lh(inout dst: reg32, in src1: reg32, in src2: imm32)
    // {:instruction Ins32(RV_LH(dst, src1, src2))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + src2);
        // src1 < 0x10000; // 16-bit
        // src2 < 0x1000;  // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + old(src2));
        // // mem location = sign-extended src + sign-extended immediate
        // dst == mem[old(src1) + old(src2)];
// {
    // assume false;
// }
// 
// procedure lhu(inout dst: reg32, in src1: reg32, in src2: imm32)
    // {:instruction Ins32(RV_LHU(dst, src1, src2))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + src2);
        // src1 < 0x10000; // 16-bit
        // src2 < 0x1000;  // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + old(src2));
        // // mem location = zero-extended src + zero-extended immediate
        // dst == mem[old(src1) + old(src2)];
// {
    // assume false;
// }
// 
// procedure lb(inout dst: reg32, in src1: reg32, in src2: imm32)
    // {:instruction Ins32(RV_LB(dst, src1, src2))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + src2);
        // src1 < 0x100; // 8-bit
        // src2 < 0x1000;  // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + old(src2));
        // // mem location = sign-extended src + sign-extended immediate
        // dst == mem[old(src1) + old(src2)];
// {
    // assume false;
// }
// 
// procedure lbu(inout dst: reg32, in src1: reg32, in src2: imm32)
    // {:instruction Ins32(RV_LBU(dst, src1, src2))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + src2);
        // src1 < 0x100; // 8-bit
        // src2 < 0x1000;  // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + old(src2));
        // // mem location = zero-extended src + zero-extended immediate
        // dst == mem[old(src1) + old(src2)];
// {
    // assume false;
// }
// 
// --------------------------------------------------------------

// todo(?): fence fencei

// --------------------------------------------------------------

// immediate instructions
    
procedure addi(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_ADDI(dst, src1, src2))}
    requires
       src1 + src2 < 0xffff_ffff;
    ensures
        dst == old(src1) + old(src2);
{
    assume false;
}
    
// pseudo-instruction: mv dst src is addi dst src 0
procedure mv(inout dst: reg32, in src: reg32)
    {:instruction Ins32(RV_ADDI(dst, src, 0))}
    ensures
        dst == old(src);
{
    assume false;
}

procedure slli(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SLLI(dst, src1, src2))}
    requires
        src2 < 32;
    ensures
        // left shift src1 by amount in lowest 5 bits of src2
        dst == uint32_ls(old(src1), old(src2) % 32);
{
    assume false;
}
    
procedure slti(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SLTI(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
    dst == uint32_lt(old(src1), old(src2));
{
    assume false;
}

procedure sltiu(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SLTIU(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
       dst == uint32_lt(old(src1), old(src2));
{
    assume false;
}

procedure xori(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_XORI(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == uint32_xor(old(src1), old(src2));
{
    assume false;
}

procedure ori(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_ORI(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == uint32_or(old(src1), old(src2));
{
    assume false;
}

procedure andi(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_ANDI(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == uint32_and(old(src1), old(src2));
{
    assume false;
}

    
procedure srli(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SRLI(dst, src1, src2))}
    requires
        0 <= src2 < 31;
    ensures
        dst == uint32_rs(old(src1), old(src2));
{
    assume false;
}

procedure srai(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SRAI(dst, src1, src2))}
    requires
        // limit to non-negative values for our use case
        0 <= src2 < 31;
    ensures
        dst == uint32_rs(old(src1), old(src2));
{
    assume false;
}


// "forms 32-bit offset from 20-bit immediate, filling in the
// lowest 12 bits with zeros, adds this offset to the pc, and
// puts the result in dst"
// procedure auipc(inout dst: reg32, in src: imm32)
//     {:instruction Ins32(RV_AUIPC(dst, src))}
//     modifies
//         pc; 
//     requires
//         src < 0x100000; // 20-bit immediate
//     ensures
//         pc = old(pc) + uint32_sl(old(src), 12);
//         dst == pc; // TODO: Is this ok/is the PC updated at this point?
// {
//     assume false;
// }


// --------------------------------------------------------------
    
// store instructions
    
// TODO: double-check semantics
procedure sw(in rs2: reg32, in base: reg32, in offset: imm32, ghost iter: iter_t)
    returns (ghost next_iter: iter_t)
    {:instruction Ins32(RV_SW(rs2, base, offset))}
    modifies
        mem;
    requires
        iter_safe(iter, mem, base + offset);
        offset < 0x1000;
    ensures
        // store rs2 at mem[base + offset]
        mem == old(mem[iter.base_addr := mem[iter.base_addr][iter.index := rs2]]);
        iter_inv(next_iter, mem, base + offset + 4);
        next_iter == sw_next_iter(iter, rs2);
{
    assume false;
}

// procedure sh(inout src1: reg32, in src2: reg32, in offset: imm32)
    // {:instruction Ins32(RV_SH(src1, src2, offset))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + offset);
        // src2 < 0x10000; // 16-bit
        // offset < 0x1000; // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + offset);
        // // mem location = src1 + sign-extended offset, store signed src2 value at mem location
        // mem[old(src1) + offset] == old(src2);
// {
    // assume false;
// }
// 
// procedure sb(inout src1: reg32, in src2: reg32, in offset: imm32)
    // {:instruction Ins32(RV_SB(src1, src2, offset))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + offset);
        // src2 < 0x100; // 8-bit
        // offset < 0x1000; // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + offset);
        // // mem location = src1 + sign-extended offset, store signed src2 value at mem location
        // mem[old(src1) + offset] == old(src2);
// {
    // assume false;
// }
// 
// --------------------------------------------------------------

// register-register operations
    
procedure add(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_ADD(dst, src1, src2))}
    requires
       src1 + src2 < 0xffff_ffff;
    ensures
        dst == old(src1 + src2);
{
    assume false;
}

// add instruction where we expect/allow an overflow to occur
procedure add_wrap(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_ADD(dst, src1, src2))}
    ensures
        dst == uint32_add(old(src1), old(src2));
{
    assume false;
}

procedure sub(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SUB(dst, src1, src2))}
    requires
        src1 - src2 >= 0;
    ensures
        dst == old(src1 - src2);
{
    assume false;
}

procedure sll(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SLL(dst, src1, src2))}
    ensures
        // left shift src1 by amount in lowest 5 bits of src2
        dst == uint32_ls(old(src1), old(src2) % 32);
{
    assume false;
}

procedure slt(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SLT(dst, src1, src2))}
    ensures
        // < comparison as signed ints
        dst == uint32_lt(old(src1), old(src2));
{
    assume false;
}

procedure sltu(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SLTU(dst, src1, src2))}
    ensures
        // < comparison as unsigned ints
        dst == uint32_lt(old(src1), old(src2));
{
    assume false;
}

procedure xor(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_XOR(dst, src1, src2))}
    ensures
        dst == uint32_xor(old(src1), old(src2));
{
    assume false;
}

procedure srl(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SRL(dst, src1, src2))}
    requires
        // limit to non-negative values for our use case
        0 <= src2 < 31;
    ensures
        // right logical shift by lowest 5 bits of src2
        dst == uint32_rs(old(src1), old(src2));
{
    assume false;
}

procedure sra(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SRA(dst, src1, src2))}
    requires
         0 <= src2 < 31;
    ensures
        // right arithmetic shift by lowest 5 bits of src2
        dst == uint32_rs(old(src1), old(src2));
{
    assume false;
}

procedure or(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_OR(dst, src1, src2))}
    ensures
        dst == uint32_or(old(src1), old(src2));
{
    assume false;
}

procedure and(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_AND(dst, src1, src2))}
    ensures
        dst == uint32_and(old(src1), old(src2));
{
    assume false;
}

procedure lui(inout dst: reg32, in src: imm32)
    {:instruction Ins32(RV_LUI(dst, src))}
    requires
        src < 0x100000; // 20-bit immediate
    ensures
        dst == uint32_ls(old(src), 12);
{
    assume false;
}

procedure li(inout dst: reg32, in src: imm32)
    {:instruction Ins32(RV_LI(dst, src))}
    ensures
        dst == src;
{
    assume false;
}

// --------------------------------------------------------------
    
// branch instructions
    
// procedure beq(in src1: reg32, in src2: reg32, in imm: imm32)
//     {:instruction Ins32(RV_BEQ(src1, src2, imm))}
//     requires
//         imm < 0x1000; // 12-bit immediate
//     ensures
//         let new_pc := old(pc) + old(imm);
//         if (old(src1) == old(src2)) then dst == new_pc else dst == old(dst);
// {
//     assume false;
// }
// 
// procedure bne(in src1: reg32, in src2: reg32, in imm: imm32)
//     {:instruction Ins32(RV_BNE(src1, src2, imm))}
//     requires
//         imm < 0x1000; // 12-bit immediate
//     ensures
//         let new_pc := old(pc) + old(imm);
//         if (old(src1) == old(src2)) then dst == old(dst) else dst == new_pc;
// {
//     assume false;
// }
//     
// procedure blt(in src1: reg32, in src2: reg32, in imm: imm32)
//     {:instruction Ins32(RV_BLT(src1, src2, imm))}
//     requires
//         imm < 0x1000; // 12-bit immediate
//     ensures
//         let new_pc := old(pc) + old(imm);
//         if (old(src1) < old(src2)) then dst == new_pc else dst == old(dst);
// {
//     assume false;
// }
//     
// procedure bge(in src1: reg32, in src2: reg32, in imm: imm32)
//     {:instruction Ins32(RV_BGE(src1, src2, imm))}
//     requires
//         imm < 0x1000; // 12-bit immediate
//     ensures
//         let new_pc := old(pc) + old(imm);
//         if (old(src1) >= old(src2)) then dst == new_pc else dst == old(dst);
// {
//     assume false;
// }
//     
// procedure bltu(in src1: reg32, in src2: reg32, in imm: imm32)
//     {:instruction Ins32(RV_BLTU(src1, src2, imm))}
//     requires
//         imm < 0x1000; // 12-bit immediate
//     ensures
//         let new_pc := old(pc) + old(imm);
//         if (old(src1) < old(src2)) then dst == new_pc else dst == old(dst);
// {
//     assume false;
// }
//     
// procedure bgeu(in src1: reg32, in src2: reg32, in imm: imm32)
//     {:instruction Ins32(RV_BGEU(src1, src2, imm))}
//     requires
//         imm < 0x1000; // 12-bit immediate
//     ensures
//         let new_pc := old(pc) + old(imm);
//         if (old(src1) >= old(src2)) then dst == new_pc else dst == old(dst);
// {
//     assume false;
// }
//     
// // --------------------------------------------------------------
//     
// // jump instructions
// 
// procedure jalr(inout dst: reg32, in src1: reg32, in src2: imm32)
//     {:instruction Ins32(RV_JALR(dst, src1, src2))}
//     requires
//         src < 0x1000; // 12-bit immediate
//     ensures
//         dst == old(pc) + 4;
// {
//     assume false;
// }
// 
// // standard convention uses x1 as the return address register and x5
// // as an alternate link register
// procedure jal(inout dst: reg32, in src: imm32)
//     {:instruction Ins32(RV_JAL(dst, src))}
//     modifies
//         pc;
//     requires
//         // src encodes a signed offset in multiples of 2 bytes
//         src < 0x100000; // 20-bit immediate
//     ensures
//         // stores address of the instruction following the jump (pc + 4) in dst
//         dst == old(pc) + 4;
//         // offset is added to src and least significant bit set to 0
//         // TODO: check for new pc % 2 == 1
//         pc == old(src) + src;
// {
//     assume false;
// }
// 

// --------------------------------------------------------------
// Integer Multiplication and Division Extension
// --------------------------------------------------------------

// todo: mulh mulshu div divu rem remu

procedure mul(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_MUL(dst, src1, src2))}
    ensures
        dst == uint32_mul(old(src1), old(src2));
{
    assume false;
}

procedure mulhu(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_MULHU(dst, src1, src2))}
    ensures
        dst == uint32_mulhu(old(src1), old(src2));
{
    assume false;
}
    
#verbatim
} // end module bignum_decls
#endverbatim
