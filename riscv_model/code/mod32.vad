include "decls.vad"

#verbatim
include "../code/vale.dfy"
include "../gen/decls.dfy"
include "../spec/rsa_ops.dfy"
include "../code/mod32_lemmas.dfy"

module mul256 {

import opened bv_ops
import opened rv_ops
import opened rsa_ops
import opened rv_consts
import opened rv_decls
import opened rv_vale
import opened mod32_lemmas

#endverbatim

ghost procedure lemma_uint64_half_split(ghost x: nat) extern;
ghost procedure sub_mod32_correct_lemma(
       ghost a: uint32,
       ghost b: uint32,
       ghost c: uint32,
       ghost x10: uint32,
       ghost x11: uint32,
       ghost x15: uint32
) extern;
    
function seq_subb(xs: seq(uint32), ys: seq(uint32)) : tuple(seq(uint32), uint1) extern;
function int64_rs(x: int64, shift: nat) : int64 extern;
function sub_mod32_update_A(A: int, a: int, n: int) : int64 extern;

ghost procedure lemma_sub_mod32_correct(
      ghost A: int64_view_t, // old A
      ghost A': int64_view_t, // new A
      ghost iter_a: iter_t,
      ghost iter_n: iter_t,
      ghost iter_a': iter_t,
      ghost iter_a_next: iter_t,
      ghost iter_n_next: iter_t,
      ghost iter_a'_next: iter_t
) extern;
    
procedure sub_mod32(ghost iter_n: iter_t, ghost iter_a: iter_t)
    returns (ghost iter_a': iter_t)
    requires
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384;
    
        iter_safe(iter_a, mem, x10);
        seq_len(iter_a.buff) == 384;
    modifies
        x10; x11; x12; x13; x14; x15; x16; mem;
    ensures
        // iter valid for n
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384 ;

        // iter valid for a
        iter_safe(iter_a, mem, 71192);
        seq_len(iter_a.buff) == 384 ;

        to_nat(iter_a'.buff) == (to_nat(iter_a.buff) - to_nat(iter_n.buff));
{
    ghost var a := x10;
    ghost var n := x12;

    // load address of n
    lui(x12, 0x11); // 0x11000 into x12
    addi(x12, x12, 1560); // 71192 in x12

    // pointer to end of n
    addi(x16 ,x12, 384);  // 71575 in x16

    // set A to 0
    li(x15, 0); // 0 in x15 -- lower half of A
    li(x11, 0); // 0 in x11 -- upper half of A

    ghost var A := int64_cons(x15, x11, 0);
    assert(valid_int64_view(A, x15, x11));
    
    iter_a' := iter_a;
    ghost var iter_a := iter_a;
    ghost var iter_n := iter_n;
    while (x12 != x16)
        invariant iter_inv(iter_a', mem, x10); 
        invariant iter_inv(iter_n, mem, x12);
        invariant valid_int64_view(A, x15, x11);
        invariant ((-1) <= A.full);
        invariant (A.full <= 0);
        invariant iter_a.index == iter_a'.index;
        invariant iter_a'.index == iter_n.index;
        invariant seq_subb(iter_a.buff[0..iter_a.index], iter_n.buff[0..iter_n.index]) == tuple(iter_a'.buff[0..iter_a'.index], neg1_to_uint1(A.full));
        decreases x16 - x12;
    {
        let iter_a_next := lw_safe(x14, x10, 0, iter_a'); // load mem from x10 to x14 (x14 == a[i])
        let iter_n_next := lw_safe(x13, x12, 0, iter_n); // load mem from x12 into x13 (x13 == n[i])

        addi(x12, x12, 4); // increment n pointer

        add(x15, x15, x14); // lower half of A += a[i]
        sub(x13, x15, x13); // lower half of A -= n[i]

        sltu(x14, x15, x14); // 1 in x14 if x15 < x14 -- overflow check from add
        add(x14, x14, x11); // add carry bit to upper half of A

        sltu(x15, x15, x13); // underflow check from sub

        // a[i] == lower half of A
        // storing lower old(A) + a[i] - n[i]
        let iter_a'_next := sw(x13, x10, 0, iter_a');

        sub(x15, x14, x15); // subtract underflow carry from upper half of A
    
        // srai is sign-preserving, so shifting by 31 bits results in all 0's or all 1's
        srai(x11, x15, 0x1f); // right arith shift by 31 -- x11 == uh(A)
    
        // new A is signed old A, shifted by 32
        ghost var A' := int64_cons(x15, x11, int64_rs(sub_mod32_update_A(A.full, a, n), 32));
    
        addi(x10, x10, 4); // increment a pointer
    
        lemma_sub_mod32_correct(A, A', iter_a, iter_n, iter_a', iter_a_next, iter_n_next, iter_a'_next);

        // update variables for next loop
        A := A';
        iter_a := iter_a_next;
        iter_n := iter_n_next;
        iter_a' := iter_a'_next;

    }

}
        
#verbatim
}
#endverbatim
