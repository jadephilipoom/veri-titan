include "decls.vad"

#verbatim
include "../code/vale.dfy"
include "../gen/decls.dfy"
include "../spec/rsa_ops.dfy"

module mul256 {

import opened bv_ops
import opened rv_ops
import opened rsa_ops
import opened rv_consts
import opened rv_decls
import opened rv_vale

#endverbatim

ghost procedure lemma_uint64_half_split(ghost x: nat) extern;
ghost procedure sub_mod32_correct_lemma(
       ghost a: uint32,
       ghost b: uint32,
       ghost c: uint32,
       ghost x10: uint32,
       ghost x11: uint32,
       ghost x15: uint32
) extern;


// static void sub_mod(const uint32_t *n, uint32_t *a)
// {
//   int64_t A = 0;
//   uint32_t i;
//   for (i = 0; i < RSANUMWORDS; ++i) {
//     A += (uint64_t)a[i] - n[i];
//     a[i] = (uint32_t)A;
//     A >>= 32;
//   }
// }
    
//    lui	a2,0x11
//    addi	a2,a2,1560 # 11618 <n>
//    addi	a6,a2,384

//    li	a5, 0
//    li	a1, 0
//    lw	a4, 0(a0)
//    lw	a3, 0(a2)

//    addi	a2,a2,4
//    add	a5,a5,a4
//    sub	a3,a5,a3
//    sltu	a4,a5,a4
//    add	a4,a4,a1
//    sltu	a5,a5,a3
//    sw	a3,0(a0)
//    sub	a5,a4,a5
//    srai	a1,a5,0x1f
//    addi	a0,a0,4
//    bne	a6,a2,1016c <sub_mod.constprop.0+0xe>

procedure sub_mod32(ghost iter_n: iter_t, ghost iter_a: iter_t)
    returns (ghost iter_a': iter_t)
    requires
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384;
    
        iter_safe(iter_a, mem, x10);
        seq_len(iter_a.buff) == 384;
    modifies
        x10; x11; x12; x13; x14; x15; x16; mem;
    ensures
        // iter valid for n
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384 ;
        // iter valid for a

        // to_nat(iter_a'.buff) == to_nat(iter_a.buff) - to_nat(iter_n.buff)
{
    ghost var a := x10;
    ghost var n := x12;

    // load address of n
    lui(x12, 0x11); // 0x11000 into x12
    addi(x12, x12, 1560); // 71192 in x12

    // pointer to end of n
    addi(x16 ,x12, 384);  // 71575 in x16

    // set A to 0
    li(x15, 0); // 0 in x15 -- lower half of A
    li(x11, 0); // 0 in x11 -- upper half of A

    ghost var A := int64_cons(x15, x11, 0);
    assert(valid_int64_view(A, x15, x11));
    
    iter_a' := iter_a;
    ghost var iter_n := iter_n;
    while (x12 != x16)
        invariant iter_inv(iter_a', mem, x10); 
        invariant iter_inv(iter_n, mem, x12);
        invariant valid_int64_view(A, x15, x11);
    decreases x16 - x12;
    {
        let _ := lw_safe(x14, x10, 0, iter_a'); // load mem from x10 to x14 (x14 == a[i])
        iter_n := lw_safe(x13, x12, 0, iter_n); // load mem from x12 into x13 (x13 == n[i])

        addi(x12, x12, 4); // increment x12 (increment n)

        add(x15, x15, x14); // lower half of A += a[i]
        sub(x13, x15, x13); // lower half of A -= n[i]

        sltu(x14, x15, x14); // 1 in x14 if x15 < x14 -- overflow check from add
        add(x14, x14, x11); // add carry bit to upper half of A

        sltu(x15, x15, x13); // underflow check from sub

        // a[i] == lower half of A
        // store x13 at address in x10
        // storing lower old(A) + a[i] - n[i]
        iter_a' := sw(x13, x10, 0, iter_a'); // store x13 at address in x10 -- line 348

        sub(x15, x14, x15); // subtract underflow carry from upper half of A
    
        // srai is sign-preserving, so shifting by 31 bits results in all 0's or all 1's
        srai(x11, x15, 0x1f); // right arith shift by 31 -- x11 == uh(A)
    
        // new A is signed old A, shifted by 32
        A := int64_cons(x15, x11, (A + a - n) >> 32);
        addi(x10, x10, 4); // pointer inc

    }

}
        
#verbatim
}
#endverbatim
