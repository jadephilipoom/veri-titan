include "decls.vad"

#verbatim
include "../code/vale.dfy"
include "../gen/decls.dfy"
include "../spec/rsa_ops.dfy"
include "../code/mod32_lemmas.dfy"

module mul256 {

import opened bv_ops
import opened rv_ops
import opened rsa_ops
import opened rv_consts
import opened rv_decls
import opened rv_vale
import opened mod32_lemmas

#endverbatim

ghost procedure lemma_uint64_half_split(ghost x: nat) extern;
ghost procedure sub_mod32_correct_lemma(
       ghost a: uint32,
       ghost b: uint32,
       ghost c: uint32,
       ghost x10: uint32,
       ghost x11: uint32,
       ghost x15: uint32
) extern;

function seq_subb(xs: seq(uint32), ys: seq(uint32)) : tuple(seq(uint32), uint1) extern;
function int64_rs(x: int64, shift: nat) : int64 extern;
function sub_mod32_update_A(A: int, a: int, n: int) : int64 extern;

ghost procedure lemma_sub_mod32_correct(
      ghost A: int64_view_t, // old A
      ghost A': int64_view_t, // new A
      ghost iter_a: iter_t,
      ghost iter_n: iter_t,
      ghost iter_a': iter_t,
      ghost iter_a_next: iter_t,
      ghost iter_n_next: iter_t,
      ghost iter_a'_next: iter_t,
      ghost carry_add: int,
      ghost carry_sub: int,
      ghost x13: uint32,
      ghost i: int
) extern;

procedure sub_mod32(ghost iter_n: iter_t, ghost iter_a: iter_t)
    returns (ghost iter_a': iter_t)
    requires
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384;

        iter_safe(iter_a, mem, x10);
        seq_len(iter_a.buff) == 384;
    modifies
        x10; x11; x12; x13; x14; x15; x16; mem;
    ensures
        // iter valid for n
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384 ;

        // iter valid for a
        iter_safe(iter_a, mem, 71192);
        seq_len(iter_a.buff) == 384 ;

        to_nat(iter_a'.buff) == (to_nat(iter_a.buff) - to_nat(iter_n.buff));
{
    ghost var a := x10;
    ghost var n := x12;

    // load address of n
    lui(x12, 0x11); // 0x11000 into x12
    addi(x12, x12, 1560); // 71192 in x12

    // pointer to end of n
    addi(x16 ,x12, 384);  // 71575 in x16

    // set A to 0
    li(x15, 0); // 0 in x15 -- lower half of A
    li(x11, 0); // 0 in x11 -- upper half of A

    ghost var A := int64_cons(x15, x11, 0);
    assert(valid_int64_view(A, x15, x11));

    iter_a' := iter_a;
    ghost var iter_a := iter_a;
    ghost var iter_n := iter_n;
    while (x12 != x16)
        invariant iter_inv(iter_a', mem, x10);
        invariant iter_inv(iter_n, mem, x12);
        invariant valid_int64_view(A, x15, x11);
        invariant ((-1) <= A.full);
        invariant (A.full <= 0);
        invariant iter_a.index == iter_a'.index;
        invariant iter_a'.index == iter_n.index;
        invariant seq_subb(iter_a.buff[0..iter_a.index], iter_n.buff[0..iter_n.index]) == tuple(iter_a'.buff[0..iter_a'.index], neg1_to_uint1(A.full));
        decreases x16 - x12;
    {
        let _ := lw_safe(x14, x10, 0, iter_a'); // load mem from x10 to x14 (x14 == a[i])
        let iter_a_next := lw_next_iter(iter_a);
        let iter_n_next := lw_safe(x13, x12, 0, iter_n); // load mem from x12 into x13 (x13 == n[i])

        addi(x12, x12, 4); // increment n pointer

        add(x15, x15, x14); // lower half of A += a[i]
        sub(x13, x15, x13); // lower half of A -= n[i]

        sltu(x14, x15, x14); // overflow check from add
        let carry_add := x14;
        add(x14, x14, x11); // add carry bit to upper half of A

        sltu(x15, x15, x13); // underflow check from sub
        let carry_sub := x15;

        // a[i] == lower half of A
        // storing lower old(A) + a[i] - n[i]
        let iter_a'_next := sw(x13, x10, 0, iter_a');

        sub(x15, x14, x15); // subtract underflow carry from upper half of A

        // srai is sign-preserving, so shifting by 31 bits results in all 0's or all 1's
        srai(x11, x15, 0x1f); // right arith shift by 31 -- x11 == uh(A)

        // new A is signed old A, shifted by 32
        ghost var A' := int64_cons(x15, x11, int64_rs(sub_mod32_update_A(A.full, a, n), 32));

        addi(x10, x10, 4); // increment a pointer

        lemma_sub_mod32_correct(A, A', iter_a, iter_n, iter_a', iter_a_next, iter_n_next, iter_a'_next, carry_add, carry_sub, x13, iter_a.index);

        // update variables for next loop
        A := A';
        iter_a := iter_a_next;
        iter_n := iter_n_next;
        iter_a' := iter_a'_next;
    }
}
    
// static int ge_mod(const uint32_t *n, const uint32_t *a)
// {
//   uint32_t i;
//   for (i = RSANUMWORDS; i;) {
//     --i;
//     if (a[i] < n[i])
//       return 0;
//     if (a[i] > n[i])
//       return 1;
//   }
//   return 1;  /* equal */
// }
    
   //  var cond := 1; // x12
   //  var return := 1; // x10
   //  while cond != 0 {
   //      // load a[i], n[i]
   //      if a[i] != n[i] {
   //          cond = 0
   //          }
   //      if a[i] < n[i] {
   //          return = 0
   //      }
   //      a--;
   //      n--;
   //      if n == start_n {
   //          cond = 0
   //      }
   //  }
    
procedure ge_mod32(ghost iter_n: iter_t, ghost iter_a: iter_t)
    returns (ghost result: bool)
    requires
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384;

        iter_safe(iter_a, mem, x10);
        seq_len(iter_a.buff) == 384;
    
        // TODO: should be hard-coded in the semantics
        x0 == 0;
    reads
        x0; mem;
    modifies
        x10; x11; x12; x13; x14; x15;
    ensures
        // iter valid for n
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384 ;

        // iter valid for a
        iter_safe(iter_a, mem, 71192);
        seq_len(iter_a.buff) == 384 ;
    
        result == to_nat(iter_a.buff) >= to_nat(iter_n.buff);
  {

    lui(x11 ,0x11); // 0x11000 into x11
    addi(x15, x11, 1560); // n = 71192 into x15

    addi(x10, x10, 380); // pointer to end of a
    addi(x15, x15, 380); // pointer to end of n
    addi(x11, x11, 1560); // pointer to beginning of n
    
    mv(x12, 1);

    while (x12 != 0)
    decreases x12;
    {

      lw_safe(x13, x10, 0, iter_a); // x13 = a[i] -- 10148
      lw_safe(x14, x15, 0, iter_n); // x14 = n[i]
      
      addi(x15, x15, (-4)); // x15 = pointer to n[i-1]
      addi(x10, x10, (-4)); // x10 = pointer to a[i-1]

      // if a[i] != n[i]
      sub(x12, x13, x14); // a[i] - n[i]
      sltu(x12, x0, x12); // 0 if a[i] - n[i] = 0, else 1

      // a[i] < n[i]
      slti(x10, x0, x12); // 0 if 0 < a[i] - n[i]

      xor(x12, x11, x15);
      sltu(x12, x0, x12); // 1 if 0 < x12, 0 if they're equal 
        
    }
    
    assume false;
  }


    //  // jump over branch instructions and mv
    //  j	10148 <ge_mod.constprop.0+0x1e>

    //  // if n[i] < a[i], return, otherwise they're equal
    //  bltu	x14,x13,1015a <ge_mod.constprop.0+0x30> // 1013e

    //  // jump to (ret 0) if we're at the end of n
    //  // pointer to beginning and end of n equal
    //  beq	x15,x11,1015a <ge_mod.constprop.0+0x30>
    //  
    //  mv(x15, x12) // point x15 to n[i-1] for next iteration of loop

    //  // loop body
    //  lw_safe(x13, x10, 0, iter_a); // x13 = a[i] -- 10148
    //  lw_safe(x14, x15, 0, iter_n); // x14 = n[i]
    //  
    //  addi(x12, x15, -4); // x12 = pointer to n[i-1] (x15 still points to n[i])
    //  addi(x10, x10, -4); // x10 = pointer to a[i-1]
    //  
    //  // loop if a[i] >= n[i]
    //  bgeu	x13,x14,1013e <ge_mod.constprop.0+0x14>
    //  
    //  li(x10, 0)
    //  ret
    //  
    //  li(x10, 1) // 1015a
    //  ret

#verbatim
}
#endverbatim
