include "../lib/generic_bv_ops.dfy"

{%- macro assemble(big, small) -%}
  assemble_{{small}}_to_{{big}}
{%- endmacro -%}

{%- macro select(big, small) -%}
  select_{{small}}_from_{{big}}
{%- endmacro -%}

{%- macro convert(big, small, num_words) -%}

  function method {:opaque} {{ select(big, small) }}(x: uint{{big}}, sel: nat): uint{{small}}
    requires sel < {{num_words}}
  {
    if sel == 0 then ((x as bv{{big}}) as int) % BASE_{{small}}
    {%- for n in range(1, num_words-1) %}
    else if sel == {{n}} then ((x as bv{{big}} >> {{n * small}}) as int) % BASE_{{small}}
    {%- endfor %}
    else ((x as bv{{big}} >> {{(num_words - 1) * small}}) as int) % BASE_{{small}}
  }

  function method {:opaque} {{ assemble(big, small) }}(
    {%- for n in range(0, num_words) %}
    p{{n}}: uint{{small}} {{- ", " if not loop.last -}}
    {%- endfor %}): uint{{big}}
  {
    ((p{{0}} as bv{{big}})
    {%- for n in range(1, num_words) %}
    |(p{{n}} as bv{{big}} << {{n * small}})
    {%- endfor -%}
    ) as uint{{big}}
  }

  lemma {:axiom} value_{{big}}_from_{{small}}(x: uint{{big}})
    ensures x == {{ assemble(big, small) }}(
  {%- for n in range(0, num_words) %}
      {{ select(big, small) }}(x, {{n}}) {{- ", " if not loop.last -}}
  {%- endfor %});

{%- endmacro -%}


module memory{{base_size.num_bits}} {
  import opened integers

  const DMEM_LIMIT: int := 0x8000

  // basic map
  type mem_t = map<int, uint{{base_size.num_bits}}>

{% for item in sizes %}
  predicate method uint{{item.num_bits}}_ptr_admissible(ptr: nat)
  {
    // uint{{item.num_bits}} ptr should be {{item.align}} bytes aligned
    && ptr % {{item.align}} == 0
    && (ptr + {{item.num_bytes}}) <= DMEM_LIMIT
  }

  predicate method uint{{item.num_bits}}_ptr_valid(mem: mem_t, ptr: nat)
  {
    && uint{{item.num_bits}}_ptr_admissible(ptr)
  {%- for n in range(item.num_words) %}
    && ptr + {{n * base_size.num_bytes}} in mem
  {%- endfor %}
  }

  {{ convert(item.num_bits, base_size.num_bits, item.num_words) }}

  function method read_uint{{item.num_bits}}(mem: mem_t, ptr: nat): uint{{item.num_bits}}
    requires uint{{item.num_bits}}_ptr_valid(mem, ptr)
  {
  {%- for n in range(item.num_words) %}
    var p{{n}} := mem[ptr + {{n * base_size.num_bytes}}];
  {%- endfor %}
    {{ assemble(item.num_bits, base_size.num_bits) }}(
  {%- for n in range(item.num_words) -%}
    p{{n}} {{- ", " if not loop.last -}}
  {%- endfor %})
  }

  function method write_uint{{item.num_bits}}(mem: mem_t, x: uint{{item.num_bits}}, ptr: nat): (new_mem: mem_t) 
    requires uint{{item.num_bits}}_ptr_admissible(ptr)
    ensures uint{{item.num_bits}}_ptr_valid(new_mem, ptr)
  {
    mem
  {%- for n in range(item.num_words) %}
    [ptr + {{n * base_size.num_bytes}} := {{ select(item.num_bits, base_size.num_bits) }}(x, {{n}})]
  {%- endfor %}
  }

  lemma write_read_basic_{{item.num_bits}}(mem: mem_t, x: uint{{item.num_bits}}, ptr: nat)
    requires uint{{item.num_bits}}_ptr_admissible(ptr)
    ensures read_uint{{item.num_bits}}(write_uint{{item.num_bits}}(mem, x, ptr), ptr) == x
  {
    var new_mem := write_uint{{item.num_bits}}(mem, x, ptr);
    value_{{item.num_bits}}_from_{{base_size.num_bits}}(x);
    assert read_uint{{item.num_bits}}(new_mem, ptr) == x;
  }

{% endfor %}


}