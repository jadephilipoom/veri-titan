include "decls.vad"
include "mul256.vad"
include "addc512.vad"

#verbatim
include "../code/vale.dfy"
include "../spec/vt_ops.dfy"

include "decls.dfy"
include "mul256.dfy"
include "addc512.dfy"

module mont_loop {

import opened bv_ops
import opened vt_ops
import opened vt_types
import opened vt_consts
import opened vt_vale
import opened vt_decls
import opened powers
import opened congruences

import opened mul256
import opened addc512
import opened addc512_lemmas

#endverbatim

ghost procedure to_nat_lemma1(ghost xs: seq(uint256)) extern;

ghost procedure to_nat_lemma2(ghost xs: seq(uint256)) extern;

function seq_addc_512_is_safe(xs: seq(uint256), ys: seq(uint256)): bool extern;

ghost procedure uint512_view_lemma(ghost num: uint512_view_t) extern;

procedure mont_loop_0(
    ghost a_slice: seq(uint256),
    ghost y_iter: iter_t,
    ghost x_i: uint256,
    ghost m0': nat)
    returns (ghost y_next_iter: iter_t,
        ghost p_1: uint512_view_t)

    {:frame false}

    requires
        w2 == x_i;
        w3 == m0';
        w31 == 0;

        valid_wdr_view(wdrs, a_slice, 4, NUM_WORDS);

        valid_wmem_addr(wmem, x19, y_iter);
        seq_len(y_iter.buff) == NUM_WORDS;
        y_iter.index == 0;

    ensures
        x8 == 5;
        x10 == 4;
        x12 == 30;
        x13 == 24;
        x16 == old(x16);
        x22 == x16;

        y_next_iter == bn_lid_next_iter(y_iter, true);
        valid_wmem_addr(wmem, x19, y_next_iter);

        w2 == x_i;
        w3 == m0';
        w31 == 0;

        cong_B256(w25, (a_slice[0] + y_iter.buff[0] * x_i) * m0');
        valid_wdr_view(wdrs, a_slice, 4, NUM_WORDS);
        valid_uint512_view(wdrs, p_1, 30, 29);
        p_1.full == a_slice[0] + y_iter.buff[0] * x_i;

        wmem == old(wmem);
{
   /* save pointer to modulus */
    addi(x22, x16, 0);

    /* pointers to temp. wregs */
    li(x12, 30);
    li(x13, 24);

    /* buffer read pointer */
    li(x8, 4);

    /* buffer write pointer */
    li(x10, 4);
    
    /* load 1st limb of input y (operand a): w30 = y[0] */
    y_next_iter := bn_lid_safe(x12, false, 0, x19, true, y_iter);
    // assert wdrs[30] == y_iter.buff[0];

    /* [w26, w27] = w30*w2 = y[0]*x_i */
    mul256_w30xw2();
    // assert to_nat(seq(w27, w26)) == y_iter.buff[0] * w2;

    /* w24 = w4 = A[0] */ 
    bn_movr(x13, false, x8, true);
    // assert w24 == a_slice[0];

    /* add A[0]: [w29, w30] = [w26, w27] + w24 = y[0]*x_i + A[0] */
    assume seq_addc_512_is_safe(seq(w27, w26), seq(w24, w31));
    p_1 := seq_addc_512_safe(w30, w27, w24, w29, w26, w31);

    // assert to_nat(seq(w30, w29)) == a_slice[0] + y_iter.buff[0] * x_i;

    calc ==> {
        true;
        ==> { reveal cong; }
        cong_B256(a_slice[0] + y_iter.buff[0] * x_i, p_1.full);
        ==> { uint512_view_lemma(p_1); }
        cong_B256(a_slice[0] + y_iter.buff[0] * x_i, w30 + w29 * BASE_256);
        ==> { assume false; }
        cong_B256(a_slice[0] + y_iter.buff[0] * x_i, w30);
        ==> { reveal cong; }
        cong_B256(w30, a_slice[0] + y_iter.buff[0] * x_i);
    }

    /* w25 = w3 = m0' */
    bn_mov(w25, w3);

    /* [_, u_i] = [w26, w27] = w30*w25 = (y[0]*x_i + A[0])*m0'*/
    mul256_w30xw25();

    /* [_, u_i] = [w28, w25] = [w26, w27]  */
    bn_mov(w25, w27);

    /* TODO: this instruction seems unnecessary */
    // bn_mov(w28, w26);

    calc ==> {
        to_nat(seq(w27, w26)) == w30 * m0';
        ==> { to_nat_lemma2(seq(w27, w26)); }
        w27 + w26 * BASE_256 == w30 * m0';
        ==> { reveal cong; }
        cong_B256(w27 + w26 * BASE_256, w30 * m0');
        ==> { assume false; }
        cong_B256(w27, w30 * m0');
        ==> { assert cong_B256(w30, a_slice[0] + y_iter.buff[0] * x_i);
            assume false; }
        cong_B256(w27, (a_slice[0] + y_iter.buff[0] * x_i) * m0');
        ==>
        cong_B256(w25, (a_slice[0] + y_iter.buff[0] * x_i) * m0');
    }
}

procedure mont_loop_1(
    ghost inital_a_slice: seq(uint256), 
    ghost a_slice: seq(uint256),
    ghost u_i: uint256,
    ghost x_i: uint256,
    ghost y_iter: iter_t,
    ghost m_iter: iter_t,
    ghost p_1: uint512_view_t,
    ghost p_2: uint512_view_t,
    ghost j: nat)

    returns (
        ghost next_a_slice: seq(uint256),
        ghost next_p_1: uint512_view_t,
        ghost next_p_2: uint512_view_t,
        ghost next_y_iter: iter_t,
        ghost next_m_iter: iter_t)

    {:frame false}

    requires
        x8 == 4 + j;
        x10 == 3 + j;
        x12 == 30;
        x13 == 24;

        w2 == x_i;
        w25 == u_i;
        w31 == 0;

        valid_uint512_view(wdrs, p_1, NA, 29);
        valid_uint512_view(wdrs, p_2, NA, 28);

        y_iter.index == j;
        y_iter.index >= 1;
        y_iter.index == m_iter.index;
        m_iter.base_addr != y_iter.base_addr;

        valid_wmem_addr(wmem, x19, y_iter);
        seq_len(y_iter.buff) == NUM_WORDS;
        valid_wmem_addr(wmem, x16, m_iter);
        seq_len(m_iter.buff) == NUM_WORDS;
        valid_wdr_view(wdrs, a_slice, 4, NUM_WORDS);

        // x_i * to_nat(y_iter.buff[..j]) + u_i * to_nat(m_iter.buff[..j]) + sint(A[..j])
        //     == 
        // sint(S) + p_2.uh * pow_B256(j) + p_1.uh * pow_B256(j);
    ensures
        x8 == 4 + j + 1;
        x10 == 3 + j + 1;
        x12 == 30;
        x13 == 24;

        w2 == x_i;
        w25 == u_i;
        w31 == 0;

        valid_uint512_view(wdrs, next_p_1, NA, 29);
        // next_p_1.full == p_1.uh + y_iter.buff[j] * x_i + a_slice[j];
        valid_uint512_view(wdrs, next_p_2, NA, 28);
        // next_p_2.full == m_iter.buff[j] * u_i + next_p_1.lh + p_2.uh;

        // next_y_iter.index == j + 1;
        next_y_iter == bn_lid_next_iter(y_iter, true);
        next_m_iter == bn_lid_next_iter(m_iter, true);

        admissible_wmem_addr(wmem, x19, next_y_iter);
        admissible_wmem_addr(wmem, x16, next_m_iter);
        valid_wdr_view(wdrs, next_a_slice, 4, NUM_WORDS);
{
    ghost var j := y_iter.index;
    /* load limb of y (operand a) and mult. with x_i: [w26, w27] <- y[j]*x_i */
    next_y_iter := bn_lid_safe(x12, false, 0, x19, true, y_iter);
    mul256_w30xw2();

    /* add limb of buffer: [w26, w27] <- [w26,w27] + w24 = y[j]*x_i + A[j] */
    bn_movr(x13, false, x8, true);

    assume seq_addc_512_is_safe(seq(w27, w26), seq(w24, w31));
    next_p_1 := seq_addc_512_safe(w27, w27, w24, w26, w26, w31);

    /* add carry word from previous cycle:
       [c_xy, a_tmp] = [w29, w24] <- [w26,w27] + w29 = y[j]*x_i + A[j] + c_xy*/
    uint512_view_lemma(next_p_1);
    assume seq_addc_512_is_safe(seq(w27, w26), seq(w29, w31));
    next_p_1 := seq_addc_512_safe(w24, w27, w29, w29, w26, w31);

    /* load limb m[j] of modulus and multiply with u_i:
       [w26, w27] = w30*w25 = m[j]*u_i */
    next_m_iter := bn_lid_safe(x12, false, 0, x16, true, m_iter);
    mul256_w30xw25();

    assume seq_addc_512_is_safe(seq(w27, w26), seq(w24, w31));
    next_p_2 := seq_addc_512_safe(w27, w27, w24, w26, w26, w31);

    uint512_view_lemma(next_p_2);
    assume seq_addc_512_is_safe(seq(w27, w26), seq(w28, w31));
    next_p_2 := seq_addc_512_safe(w24, w27, w28, w28, w26, w31);

    bn_movr(x10, true, x13, false);
    next_a_slice := a_slice[j-1 := w24];
    assert valid_wdr_view(wdrs, next_a_slice, 4, NUM_WORDS);

    assert valid_uint512_view(wdrs, next_p_1, NA, 29);
    assert next_p_1.full == p_1.uh + y_iter.buff[j] * x_i + a_slice[j];

    assert valid_uint512_view(wdrs, next_p_2, NA, 28);
    assert next_p_2.full == m_iter.buff[j] * u_i + next_p_1.lh + p_2.uh;
}

procedure mont_loop(
    ghost a_slice: seq(uint256),
    ghost x_i: uint256,
    ghost m0': nat)

    {:frame false}

    requires
        x31 == NUM_WORDS - 1;

        x16 != x19;

        valid_buff_addr(wmem, x19, NUM_WORDS);
        valid_buff_addr(wmem, x16, NUM_WORDS);

        valid_wdr_view(wdrs, a_slice, 4, NUM_WORDS);

        w2 == x_i;
        w3 == m0';
        w31 == 0;
{
    ghost var y_iter := iter_cons(x19, 0, wmem[x19]);
    ghost var p_1 : uint512_view_t;
    y_iter, p_1 := mont_loop_0(a_slice, y_iter, x_i, m0');
    ghost var u_i := w25;

    /* w24 = w30 =  y[0]*x_i + A[0] mod b */
    bn_mov(w24, w30);
    // assert valid_uint512_view(wdrs, p_1, 24, 29);
    // assert p_1.full == a_slice[0] + y_iter.buff[0] * x_i;

    /* load first limb of modulus: w30 = m[0] */
    ghost var m_iter := iter_cons(x16, 0, wmem[x16]);
    m_iter := bn_lid_safe(x12, false, 0, x16, true, m_iter);
    // assert w30 == m_iter.buff[0];

    /* [w26, w27] = w30*w25 = m[0]*u_i*/
    mul256_w30xw25();
    // assert to_nat(seq(w27, w26)) == m_iter.buff[0] * u_i;

    /* [w28, w27] = [w26, w27] + w24 = m[0]*u_i + (y[0]*x_i + A[0] mod b) */
    /* this serves as p_2 in the first cycle of the loop below */
    assume seq_addc_512_is_safe(seq(w27, w26), seq(w24, w31));
    let p_2 := seq_addc_512_safe(w27, w27, w24, w28, w26, w31);

    assert valid_uint512_view(wdrs, p_1, 24, 29);
    assert p_1.full == a_slice[0] + y_iter.buff[0] * x_i;

    assert valid_uint512_view(wdrs, p_2, 27, 28);
    assert p_2.full == m_iter.buff[0] * u_i + w24;

    // while (Loop(x31))
    // {
    // let _ := mont_loop_1(a_slice, u_i, x_i, y_iter, m_iter, p_1, p_2);
    // }
}

#verbatim
}
#endverbatim
