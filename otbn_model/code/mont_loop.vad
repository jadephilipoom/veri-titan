include "decls.vad"
include "mul256.vad"

#verbatim
include "../code/vale.dfy"
include "../spec/vt_ops.dfy"

include "decls.dfy"
include "mul256.dfy"

module mont_loop {

import opened bv_ops
import opened vt_ops
import opened vt_types
import opened vt_consts
import opened vt_vale
import opened vt_decls
import opened powers
import opened congruences

import opened mul256

#endverbatim

// procedure mont_loop_inner(ghost num_words: nat)
// {
// }

ghost procedure seq_addc_len2_lemma(
    ghost x0: uint256, ghost y0: uint256, ghost z0: uint256, ghost c0: uint1,
    ghost x1: uint256, ghost y1: uint256, ghost z1: uint256, ghost c1: uint1) extern;

ghost procedure seq_addc_to_nat_lemma(
    ghost xs: seq(uint256), ghost ys: seq(uint256), ghost zs: seq(uint256), ghost cout: uint1)
    extern;

ghost procedure to_nat_singleton_lemma(ghost xs: seq(uint256)) extern;

ghost procedure to_nat_pair_lemma(ghost xs: seq(uint256)) extern;

procedure mont_loop_0(
    ghost num_words: nat,
    ghost a_slice: seq(uint256),
    ghost y_iter: iter_t,
    ghost m0': nat)
    requires
        num_words <= 12;
        x31 == num_words - 1;

        valid_wmem_addr(wmem, x19, y_iter);
        seq_len(y_iter.buff) == num_words;
        y_iter.index == 0;

        seq_len(a_slice) == num_words;
        valid_wdr_slice(wdrs, a_slice, 4);

        w3 == m0';
        w31 == 0;

    reads
        x16; w2; w31;

    modifies
        wmem; wdrs; fgroups;
        w3; w24; w25; w26; w27; w29; w30;
        x8; x10; x12; x13; x19; x22;
    
    ensures
        x22 == x16;
        x12 == 30;
        x13 == 24;
        x8 == 5;

        x10 == 4;

        // cong(w25, (w24 + y_iter.buff[0] * w2) * m0', BASE_256);
{
   /* save pointer to modulus */
    addi(x22, x16, 0);

    /* pointers to temp. wregs */
    li(x12, 30);
    li(x13, 24);

    /* buffer read pointer */
    li(x8, 4);

    /* buffer write pointer */
    li(x10, 4);
    
    /* load 1st limb of input y (operand a): w30 = y[0] */
    let y_next_iter := bn_lid_safe(x12, false, 0, x19, true, y_iter);
    // assert wdrs[30] == y_iter.buff[0];

    /* [w26, w27] = w30*w2 = y[0]*x_i */
    mul256_w30xw2();
    // assert to_nat(seq(w27, w26)) == y_iter.buff[0] * w2;

    /* w24 = w4 = A[0] */ 
    bn_movr(x13, false, x8, true);
    assert w24 == a_slice[0];

    /* add A[0]: [w29, w30] = [w26, w27] + w24 = y[0]*x_i + A[0] */
    bn_add(w30, w27, w24, SFT_DFT, 0);
    ghost var cin := bool_to_uint1(fgroups.fg0.cf);
    bn_addc(w29, w26, w31, SFT_DFT, 0);
    ghost var cout := bool_to_uint1(fgroups.fg0.cf);

    calc == {
        // a_slice[0] + y_iter.buff[0] * w2;
        w24 + y_iter.buff[0] * w2;
        == { to_nat_singleton_lemma(seq(w24)); }
        to_nat(seq(w24)) + y_iter.buff[0] * w2;
        == { assert to_nat(seq(w24)) == to_nat(seq(w24, 0)); }
        to_nat(seq(w24, 0)) + y_iter.buff[0] * w2;
        == to_nat(seq(w24, 0)) + to_nat(seq(w27, w26));
        == { seq_addc_len2_lemma(w27, w24, w30, cin, w26, 0, w29, cout);
            seq_addc_to_nat_lemma(seq(w24, 0), seq(w27, w26), seq(w30, w29), cout); }
        to_nat(seq(w30, w29)) + power(BASE_256, 2) * cout;
    }
    
    calc ==> {
        cong256(w24 + y_iter.buff[0] * w2, 
            to_nat(seq(w30, w29)) + power(BASE_256, 2) * cout);
        ==> { reveal cong; }
        cong256(w24 + y_iter.buff[0] * w2, 
            to_nat(seq(w30, w29)) + power(BASE_256, 2) * cout);
        ==> { assume false; }
        cong256(w24 + y_iter.buff[0] * w2, to_nat(seq(w30, w29)));
        ==> { to_nat_pair_lemma(seq(w30, w29)); }
        cong256(w24 + y_iter.buff[0] * w2, w30 + w29 * BASE_256);
        ==> { assume false; }
        cong256(w24 + y_iter.buff[0] * w2, w30);
    }

    /* w25 = w3 = m0' */
    bn_mov(w25, w3);

    /* [_, u_i] = [w26, w27] = w30*w25 = (y[0]*x_i + A[0])*m0'*/
    mul256_w30xw25();

    /* [_, u_i] = [w28, w25] = [w26, w27]  */
    bn_mov(w25, w27);

    /* TODO: this instruction seems unnecessary */
    // bn_mov(w28, w26);

    calc ==> {
        to_nat(seq(w27, w26)) == w30 * m0';
        ==> { to_nat_pair_lemma(seq(w27, w26)); }
        w27 + w26 * BASE_256 == w30 * m0';
        ==> { reveal cong; }
        cong256(w27 + w26 * BASE_256, w30 * m0');
        ==> { assume false; }
        cong256(w27, w30 * m0');
        ==> { assume false; }
        cong256(w27, (w24 + y_iter.buff[0] * w2) * m0');
        ==>
        cong256(w25, (w24 + y_iter.buff[0] * w2) * m0');
    }

    /* w24 = w30 =  y[0]*x_i + A[0] mod b */
    bn_mov(w24, w30);

}

// procedure mont_loop(ghost num_words: nat)
//     // {: frame false}
//     requires
//         valid_buff_addr(wmem, x16, num_words);
//         valid_buff_addr(wmem, x19, num_words); // y buffer
//         x31 == num_words - 1;

//         w31 == 0;

//     reads
//         x16; w2; w31;

//     modifies
//         wmem; wdrs; fgroups;
//         w24; w26; w27; w29; w30;
//         x8; x10; x12; x13; x19; x22;

// {
 

// }

#verbatim
}
#endverbatim
