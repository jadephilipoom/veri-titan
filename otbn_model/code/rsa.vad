include "decls.vad"
include "otbn_mul.vad"

#verbatim
include "../code/vale.dfy"

include "../spec/def.dfy"
include "../spec/ops.dfy"
include "../spec/types.dfy"

include "../gen/decls.dfy"

// include "../code/rsa_leammas.dfy"

module barrett384 {

import opened bignum_vale

import opened bignum_def
import opened ops
import opened types
// import opened rsa_leammas

import opened bignum_decls

#endverbatim

function interp_wdr_seq(start: int, end: int): int extern;
function seq_subb(x: seq(uint256), y: seq(uint256)) : tuple(seq(uint256), uint1) extern;
function uint256_subb(x: uint256, y: uint256, cin: uint1): tuple(uint256, uint1) extern;

//  FG1.C: s, selection flag
procedure cond_sub_mod(ghost m: seq(uint256), ghost selection: bool)
    requires
        w31 == 0;
        x16 < 0xfffffe60;
        forall(i:int) 0 <= i < 3 ==>
            Valid256Addr(wmem, old(x16) + 32 * i);
        selection == get_cf1(fgroups);
        get_cf0(fgroups) == false;
        m == wmem_seq(wmem, old(x16), 3);

    modifies
        x8; x10; x11; x16;
        fgroups; wmem;
        wregs; w2; w3; w4; w31;
        w5; w6; w7; w8; w9; w10; w11; w12; w13; w14; w15; w16;
{
    assume selection == true;

    li(x8, 5);
    li(x10, 3);
    li(x11, 2);

    bn_add(w31, w31, w31, false, 0, 0);
    ghost var i : int := 0;
    ghost var cin :uint1 := 0;

    while (LoopImm(3))
        invariant i + loop_ctr == 3;
        invariant x8 == 5 + i;
        invariant x10 == 3;
        invariant x11 == 2;
        invariant x16 == old(x16) + 32 * i;

        invariant get_cf1(fgroups) == selection;

        invariant forall(i:int) 0 <= i < 3
            ==> Valid256Addr(wmem, old(x16) + 32 * i);

        invariant cin == bool_to_uint1(get_cf0(fgroups));

        invariant selection ==> tuple(wregs_seq(wregs, 5, x8), cin) == 
                seq_subb(wregs_seq(old(wregs), 5, x8), wmem_seq(wmem, old(x16), i));

        decreases loop_ctr;
    {
        // ghost var x_i := old_x[i];
        // ghost var y_i := m[i];
        // ghost var pre_x := wregs_seq(old(wregs), 5, x8);
        // ghost var pre_y := wmem_seq(wmem, old(x16), i);

        bn_lid_safe(x10, false, 0, x16, true);
        assert w3 == wmem[old(x16) + 32 * i];
        // assert w3 == y_i;

        bn_movr(x11, false, x8, false);
        assert w2 == wregs[Wdr(5 + i)];
        // assert w2 == x_i;

        // ghost var pre_cin := bool_to_uint1(get_cf0(fgroups));
        // ghost var pre_c := cur_c;
        // assert tuple(prefix_seq(pre_c, i), pre_cin)
        //     == seq_subb(pre_x, pre_y);

        bn_subb(w4, w2, w3, false, 0, 0);
        cin := bool_to_uint1(get_cf0(fgroups));

        bn_sel(w3, w4, w2, 1, 0);
        bn_movr(x8, true, x10, false);

        i := i + 1;

        ghost var x := wregs_seq(old(wregs), 5, x8);
        ghost var y := wmem_seq(wmem, old(x16), i);
        ghost var p3 := seq_subb(x, y);
        assert snd(p3) == cin;
        assume false;

        assert fst(p3) == wregs_seq(wregs, 5, x8);


        // assert p3 == tuple(seq_append(fst(p1), fst(p2)), snd(p2));
    }
}

#verbatim
}
#endverbatim
