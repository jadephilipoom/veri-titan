include "decls.vad"
include "otbn_mul.vad"

#verbatim
include "../code/vale.dfy"

include "../spec/def.dfy"
include "../spec/ops.dfy"
include "../spec/types.dfy"

include "../gen/decls.dfy"

// include "../code/rsa_leammas.dfy"

module barrett384 {

import opened bignum_vale

import opened bignum_def
import opened ops
import opened types
// import opened rsa_leammas

import opened bignum_decls

#endverbatim

function interp_wdr_seq(start: int, end: int): int extern;
function seq_subb(x: seq(uint256), y: seq(uint256)) : tuple(seq(uint256), uint1) extern;
function uint256_subb(x: uint256, y: uint256, cin: uint1): tuple(uint256, uint1) extern;

//  FG1.C: s, selection flag
procedure cond_sub_mod(ghost m: seq(uint256), ghost selection: bool)
    requires
        w31 == 0;
        x16 < 0xfffffe60;
        forall(i:int) 0 <= i < 3 ==>
            Valid256Addr(wmem, old(x16) + 32 * i);
        selection == get_cf1(fgroups);
        get_cf0(fgroups) == false;

        Valid256Addr(wmem, old(x16) + 0);
        Valid256Addr(wmem, old(x16) + 32);
        Valid256Addr(wmem, old(x16) + 64);
        // Valid256Addr(wmem, old(x16) + 96);
        // Valid256Addr(wmem, old(x16) + 128);
        // Valid256Addr(wmem, old(x16) + 160);
        // Valid256Addr(wmem, old(x16) + 192);
        // Valid256Addr(wmem, old(x16) + 224);
        // Valid256Addr(wmem, old(x16) + 256);
        // Valid256Addr(wmem, old(x16) + 288);
        // Valid256Addr(wmem, old(x16) + 320);
        // Valid256Addr(wmem, old(x16) + 352);

        m == seq(
            wmem[old(x16) + 0], 
            wmem[old(x16) + 32], 
            wmem[old(x16) + 64]
            // wmem[old(x16) + 96], 
            // wmem[old(x16) + 128], 
            // wmem[old(x16) + 160], 
            // wmem[old(x16) + 192], 
            // wmem[old(x16) + 224], 
            // wmem[old(x16) + 256], 
            // wmem[old(x16) + 288], 
            // wmem[old(x16) + 320], 
            // wmem[old(x16) + 352]
        );
    modifies
        x8; x10; x11; x16;
        fgroups; wmem;
        wregs; w2; w3; w4; w31;
        w5; w6; w7; w8; w9; w10; w11; w12; w13; w14; w15; w16;
{
    assume selection == true;

    li(x8, 5);
    li(x10, 3);
    li(x11, 2);

    bn_add(w31, w31, w31, false, 0, 0);
    ghost var i : int := 0;
    ghost var old_x := seq(w5, w6, w7);
    ghost var cur_c := seq(w5, w6, w7);

    ghost var cin :uint1 := 0;
    // ghost var cout :uint1 := 0;

    while (LoopImm(3))
        invariant i + loop_ctr == 3;
        invariant x8 == 5 + i;
        invariant x10 == 3;
        invariant x11 == 2;
        invariant x16 == old(x16) + 32 * i;

        invariant get_cf1(fgroups) == selection;

        invariant forall(i:int) 0 <= i < 3
            ==> Valid256Addr(wmem, old(x16) + 32 * i);

        invariant cur_c == seq(w5, w6, w7);

        invariant forall(j:int) i <= j < 3
            ==> cur_c[j] == old_x[j];

        invariant Valid256Addr(wmem, old(x16) + 0);
        invariant Valid256Addr(wmem, old(x16) + 32);
        invariant Valid256Addr(wmem, old(x16) + 64);
        invariant m == seq(wmem[old(x16) + 0], wmem[old(x16) + 32], wmem[old(x16) + 64]);

        // invariant !selection
        //     ==> (forall(i:int) 0 <= i < 12
        //     ==> wregs[Wdr(5 + i)] == old(wregs[Wdr(5 + i)]));

        invariant cin == bool_to_uint1(get_cf0(fgroups));

        invariant selection ==>
        tuple(prefix_seq(cur_c, i), cin)
            == seq_subb(prefix_seq(old_x, i), prefix_seq(m, i));

        decreases loop_ctr;
    {
        ghost var x_i := old_x[i];
        ghost var y_i := m[i];
        ghost var pre_x := prefix_seq(old_x, i);
        ghost var pre_y := prefix_seq(m, i);

        bn_lid_safe(x10, false, 0, x16, true);
        assert w3 == wmem[old(x16) + 32 * i];
        assert w3 == y_i;

        bn_movr(x11, false, x8, false);
        assert w2 == wregs[Wdr(5 + i)];
        assert w2 == x_i;

        ghost var pre_cin := bool_to_uint1(get_cf0(fgroups));
        ghost var pre_c := cur_c;
        assert tuple(prefix_seq(pre_c, i), pre_cin)
            == seq_subb(pre_x, pre_y);

        bn_subb(w4, w2, w3, false, 0, 0);
        cin := bool_to_uint1(get_cf0(fgroups));

        bn_sel(w3, w4, w2, 1, 0);
        bn_movr(x8, true, x10, false);

        i := i + 1;
        cur_c := seq(w5, w6, w7);

        // ghost var new_slice : seq(uint256) := prefix_seq(current, 0, i);
        // assert seq_concat(pre_slice, seq(temp)) == new_slice;

        ghost var x := prefix_seq(old_x, i);
        ghost var y := prefix_seq(m, i);
        ghost var p3 := seq_subb(x, y);

        ghost var idx := seq_len(x) - 1;
        assert idx == i - 1;
        ghost var p1 := seq_subb(prefix_seq(x, idx), prefix_seq(y, idx));
        ghost var p2 := uint256_subb(x[idx], y[idx], snd(p1));
        assert p3 == tuple(seq_append(fst(p1), fst(p2)), snd(p2));

        calc ==
        {
            p1;
            ==
            seq_subb(prefix_seq(x, idx), prefix_seq(y, idx));
            ==
            {
                assert pre_x == prefix_seq(x, idx);
                assert pre_y == prefix_seq(y, idx);
            }
            seq_subb(pre_x, pre_y);
            ==
            {
                assert tuple(prefix_seq(pre_c, i-1), pre_cin) 
                    == seq_subb(pre_x, pre_y);
            }
            tuple(prefix_seq(pre_c, i-1), pre_cin);
        }

        calc ==
        {
            p2;
            ==
            uint256_subb(x[idx], y[idx], snd(p1));
            ==
            {
                assert snd(p1) == pre_cin;
            }
            uint256_subb(x[idx], y[idx], pre_cin);
            ==
            {
                assert x_i == x[idx];
                assert y_i == y[idx];
            }
            tuple(w4, cin);
        }
        
        calc == 
        {
            p3;
            ==
            tuple(seq_append(fst(p1), fst(p2)), snd(p2));
            ==
            tuple(seq_append(prefix_seq(pre_c, i-1), w4), cin);

        }

        // assert tuple(w4, cin) == uint256_subb(x_i, y_i, pre_cin);

    }
}

#verbatim
}
#endverbatim
