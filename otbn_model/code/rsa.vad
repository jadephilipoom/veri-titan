include "decls.vad"
include "otbn_mul.vad"

#verbatim
include "../code/vale.dfy"

include "../spec/def.dfy"
include "../spec/ops.dfy"
include "../spec/types.dfy"

include "../gen/decls.dfy"

// include "../code/rsa_leammas.dfy"

module barrett384 {

import opened bignum_vale

import opened bignum_def
import opened ops
import opened types
// import opened rsa_leammas

import opened bignum_decls

#endverbatim

function interp_wdr_seq(start: int, end: int): int extern;
function seq_subb(x: seq(uint256), y: seq(uint256), cin: uint1) : tuple(seq(uint256), uint1) extern;
function uint256_subb(x: uint256, y: uint256, cin: uint1): tuple(uint256, uint1) extern;

//  FG1.C: s, selection flag
procedure cond_sub_mod(ghost m: seq(uint256), ghost selection: bool)
    requires
        w31 == 0;
        x16 < 0xfffffe60;
        forall(i:int) 0 <= i < 3 ==>
            Valid256Addr(wmem, old(x16) + 32 * i);
        selection == get_cf1(fgroups);
        get_cf0(fgroups) == false;

        Valid256Addr(wmem, old(x16) + 0);
        Valid256Addr(wmem, old(x16) + 32);
        Valid256Addr(wmem, old(x16) + 64);
        // Valid256Addr(wmem, old(x16) + 96);
        // Valid256Addr(wmem, old(x16) + 128);
        // Valid256Addr(wmem, old(x16) + 160);
        // Valid256Addr(wmem, old(x16) + 192);
        // Valid256Addr(wmem, old(x16) + 224);
        // Valid256Addr(wmem, old(x16) + 256);
        // Valid256Addr(wmem, old(x16) + 288);
        // Valid256Addr(wmem, old(x16) + 320);
        // Valid256Addr(wmem, old(x16) + 352);

        m == seq(
            wmem[old(x16) + 0], 
            wmem[old(x16) + 32], 
            wmem[old(x16) + 64]
            // wmem[old(x16) + 96], 
            // wmem[old(x16) + 128], 
            // wmem[old(x16) + 160], 
            // wmem[old(x16) + 192], 
            // wmem[old(x16) + 224], 
            // wmem[old(x16) + 256], 
            // wmem[old(x16) + 288], 
            // wmem[old(x16) + 320], 
            // wmem[old(x16) + 352]
        );
    modifies
        x8; x10; x11; x16;
        fgroups; wmem;
        wregs; w2; w3; w4; w31;
        w5; w6; w7; w8; w9; w10; w11; w12; w13; w14; w15; w16;
{
    assume selection == true;

    li(x8, 5);
    li(x10, 3);
    li(x11, 2);

    bn_add(w31, w31, w31, false, 0, 0);
    ghost var i : int := 0;
    ghost var old_x := seq(w5, w6, w7);

    ghost var x := seq(w5, w6, w7);
    ghost var cin :uint1 := 0;
    ghost var cout :uint1 := 0;

    while (LoopImm(3))
        invariant i + loop_ctr == 3;
        invariant x8 == 5 + i;
        invariant x10 == 3;
        invariant x11 == 2;
        invariant x16 == old(x16) + 32 * i;

        invariant get_cf1(fgroups) == selection;

        invariant forall(i:int) 0 <= i < 3
            ==> Valid256Addr(wmem, old(x16) + 32 * i);

        invariant x == seq(w5, w6, w7);

        invariant forall(j:int) i <= j < 3
            ==> x[j] == old_x[j];

        invariant Valid256Addr(wmem, old(x16) + 0);
        invariant Valid256Addr(wmem, old(x16) + 32);
        invariant Valid256Addr(wmem, old(x16) + 64);
        invariant m == seq(wmem[old(x16) + 0], wmem[old(x16) + 32], wmem[old(x16) + 64]);

        // invariant tuple(, ) == seq_subb(sub_seq(old_x, 0, i) , y[..idx])
        // invariant !selection
        //     ==> (forall(i:int) 0 <= i < 12
        //     ==> wregs[Wdr(5 + i)] == old(wregs[Wdr(5 + i)]));

        invariant seq_len(x) == 3;

        // invariant selection ==>
        // tuple(sub_seq(current, 0, i), bool_to_uint1(get_cf0(fgroups))) == seq_subb(
        //     sub_seq(old_c, 0, i), sub_seq(m, 0, i));


        decreases loop_ctr;
    {
        ghost var x_i := old_x[i];
        ghost var y_i := m[i];

        bn_lid_safe(x10, false, 0, x16, true);
        assert w3 == wmem[old(x16) + 32 * i];
        assert w3 == y_i;

        bn_movr(x11, false, x8, false);
        assert w2 == wregs[Wdr(5 + i)];
        assert w2 == x_i;

        cin := bool_to_uint1(get_cf0(fgroups));
        bn_subb(w4, w2, w3, false, 0, 0);
        cout := bool_to_uint1(get_cf0(fgroups));

        bn_sel(w3, w4, w2, 1, 0);
        bn_movr(x8, true, x10, false);

        i := i + 1;
        x := seq(w5, w6, w7);

        // ghost var new_slice : seq(uint256) := sub_seq(current, 0, i);
        // assert seq_concat(pre_slice, seq(temp)) == new_slice;

        // ghost var x := sub_seq(old_x, 0, i);
        // ghost var y := sub_seq(m, 0, i);

        // ghost var rhs := seq_subb(x, y, cin);
        // assert tuple(z0, cout) := uint256_subb(x[idx], y[idx], cin);
        assert tuple(w4, cout) == uint256_subb(x_i, y_i, cin);
        // var (zrest, cout) := seq_subb(x, y, c);
    }
}

#verbatim
}
#endverbatim
