include "decls.vad"

#verbatim
include "../code/vale.dfy"

include "../spec/def.dfy"
include "../spec/ops.dfy"
include "../spec/types.dfy"

include "../gen/decls.dfy"

// include "../code/rsa_leammas.dfy"

module barrett384 {

import opened bignum_vale

import opened bignum_def
import opened ops
import opened types
// import opened rsa_leammas

import opened bignum_decls

#endverbatim

function interp_wdr_seq(start: int, end: int): int extern;
function seq_subb(x: seq(uint256), y: seq(uint256)) : tuple(seq(uint256), uint1) extern;
function uint256_subb(x: uint256, y: uint256, cin: uint1): tuple(uint256, uint1) extern;

// TODO: Move these somewhere more central
// function ValidWregs(wregs:Wregs):bool extern;
// ghost procedure lemma_wregs_seq_update(ghost wregs:Wregs, ghost start:int, ghost end:int) extern;
// ghost procedure lemma_wmem_seq_update(ghost wmem:Wmem, ghost start:int, ghost count:int) extern;
// ghost procedure lemma_wregs_seq_unchanged(ghost wregs0: Wregs, ghost wregs1: Wregs, ghost start: int, ghost end: int) extern;

ghost procedure lemma_extend_seq_subb(
    ghost x:seq(uint256), ghost y:seq(uint256), ghost z:seq(uint256), 
    ghost cin:uint1, ghost cout:uint1,
    ghost new_x:uint256, ghost new_y:uint256, ghost new_z:uint256) extern;

ghost procedure lemma_empty_seq_subb() extern;

procedure cond_sub_mod_inner(
    ghost initial_wregs: wideRegs,
    ghost initial_x16: nat,
    ghost num_words: nat,
    ghost selection: bool,
    ghost i: nat,
    ghost loop_ctr: int)

    requires
        x8 == 5 + i;
        x10 == 3;
        x11 == 2;
        x16 == initial_x16 + 32 * i;

        initial_x16 < 0xfffffe60;
        num_words <= 12;

        0 <= loop_ctr <= num_words;
        i + loop_ctr == num_words;
        i < num_words;

        wregs_seq(wregs, x8, 5 + num_words) == wregs_seq(initial_wregs, x8, 5 + num_words);

        forall(i:int) 0 <= i < num_words
            ==> Valid256Addr(wmem, initial_x16 + 32 * i);

        selection == get_cf1(fgroups);

        selection ==>
            tuple(wregs_seq(wregs, 5, x8), bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(wregs_seq(initial_wregs, 5, x8), wmem_seq(wmem, initial_x16, i));
        
        !selection ==>
            wregs_seq(wregs, 5, x8) == wregs_seq(initial_wregs, 5, x8);
    reads
        wmem;
    modifies
        x8; x10; x11; x16;
        fgroups;
        wregs; w2; w3; w4; 
    ensures
        x8 == 5 + i + 1;
        x10 == 3;
        x11 == 2;
        x16 == initial_x16 + 32 * (i + 1);

        wregs_seq(wregs, x8, 5 + num_words) == wregs_seq(initial_wregs, x8, 5 + num_words);

        selection == get_cf1(fgroups);

        forall(i:int) 0 <= i < num_words
            ==> Valid256Addr(wmem, initial_x16 + 32 * i);

        selection ==> 
            tuple(wregs_seq(wregs, 5, x8), bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(wregs_seq(initial_wregs, 5, x8), wmem_seq(wmem, initial_x16, i+1));

        !selection ==>
            wregs_seq(wregs, 5, x8) == wregs_seq(initial_wregs, 5, x8);
{
    ghost var widx := x8;

    bn_lid_safe(x10, false, 0, x16, true);
    bn_movr(x11, false, x8, false);

    ghost var cin := bool_to_uint1(get_cf0(fgroups));
    bn_subb(w4, w2, w3, false, 0, 0);
    ghost var cout := bool_to_uint1(get_cf0(fgroups));

    bn_sel(w3, w4, w2, 1, 0);
    bn_movr(x8, true, x10, false);

    ghost if (selection) {
        ghost var x := initial_wregs[widx];
        ghost var y := wmem[initial_x16 + 32 * i];
        ghost var z := wregs[widx];

        ghost var xs := wregs_seq(initial_wregs, 5, widx);
        ghost var ys := wmem_seq(wmem, initial_x16, i);
        ghost var zs := old(wregs_seq(wregs, 5, x8));

        lemma_extend_seq_subb(
            xs, ys, zs,
            cin, cout, x, y, z);
        
        assert wregs_seq(initial_wregs, 5, x8) == seq_append(xs, x);
        assert wregs_seq(wregs, 5, x8) == seq_append(zs, z);
    } else {
        calc == {
            wregs_seq(initial_wregs, 5, widx + 1);
            == seq_append(wregs_seq(initial_wregs, 5, widx), initial_wregs[widx]);
            == { assert wregs[widx] == initial_wregs[widx];}
            seq_append(wregs_seq(initial_wregs, 5, widx), wregs[widx]);
            == { assert wregs_seq(wregs, 5, widx) == wregs_seq(initial_wregs, 5, widx);}
            seq_append(wregs_seq(wregs, 5, widx), wregs[widx]);
            ==
            wregs_seq(wregs, 5, widx + 1);
        }
    }
}

procedure cond_sub_mod() // {:frame false}
    requires
        x31 <= 12;
        x16 < 0xfffffe60;

        w31 == 0;

        get_cf0(fgroups) == false;

        forall(i:int) 0 <= i < x31 ==>
            Valid256Addr(wmem, old(x16) + 32 * i);
    reads
        wmem; x31;
    modifies
        x8; x10; x11; x16;
        fgroups; 
        wregs; w2; w3; w4; w31;
{
    ghost var selection := get_cf1(fgroups);
    ghost var num_words := x31;

    li(x8, 5);
    li(x10, 3);
    li(x11, 2);

    bn_add(w31, w31, w31, false, 0, 0);
    ghost var i: nat := 0;
    ghost var initial_wregs := wregs;
    ghost var initial_x16 := x16;

    lemma_empty_seq_subb();

    while (Loop(x31))
        invariant i + loop_ctr == num_words;
        invariant x8 == 5 + i;
        invariant x10 == 3;
        invariant x11 == 2;
        invariant x16 == initial_x16 + 32 * i;

        invariant get_cf1(fgroups) == selection;

        invariant wregs_seq(wregs, x8, 5 + num_words) == wregs_seq(initial_wregs, x8, 5 + num_words);

        invariant forall(i:int) 0 <= i < num_words
            ==> Valid256Addr(wmem, initial_x16 + 32 * i);

        invariant selection ==>
            tuple(wregs_seq(wregs, 5, x8), bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(wregs_seq(initial_wregs, 5, x8), wmem_seq(wmem, initial_x16, i));
        
        invariant !selection ==>
            wregs_seq(wregs, 5, x8) == wregs_seq(initial_wregs, 5, x8);

        invariant wmem == old(wmem);
        decreases loop_ctr;
    {
        cond_sub_mod_inner(initial_wregs, initial_x16, num_words, selection, i, loop_ctr);
        i := i + 1;
    }
}

#verbatim
}
#endverbatim