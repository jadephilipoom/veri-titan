include "decls.vad"

#verbatim
include "../code/vale.dfy"

include "../spec/def.dfy"
include "../spec/ops.dfy"
include "../spec/types.dfy"

include "../gen/decls.dfy"

module cond_sub_mod {

import opened bignum_vale

import opened bignum_def
import opened ops
import opened types

import opened bignum_decls

#endverbatim

function seq_subb(x: seq(uint256), y: seq(uint256)) : tuple(seq(uint256), uint1) extern;

ghost procedure lemma_empty_seq_subb() extern;

procedure cond_sub_to_reg_inner(
    ghost initial_wdrs: wdrs_t,
    ghost initial_x8: nat,
    ghost final_x8: nat,

    ghost initial_x16: nat,
    ghost num_words: nat,
    ghost selection: bool,
    ghost i: nat)

    requires
        i < num_words;
        selection == get_cf1(fgroups);
        num_words <= 12;
        final_x8 == initial_x8 + num_words;
        final_x8 < 24;

        x8 == initial_x8 + i;
        x16 == initial_x16 + 32 * i;
        x12 == 30;
        x13 == 24;

        wdrs[x8..final_x8] == initial_wdrs[x8..final_x8];

        initial_x16 < 0xfffffe60;
        forall(i:int) 0 <= i < num_words
            ==> valid_wmem_addr(wmem, initial_x16 + 32 * i);

        selection ==>
            tuple(wdrs[initial_x8..x8], bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(initial_wdrs[initial_x8..x8], wmem_seq(wmem, initial_x16, i));

        !selection ==>
            wdrs[initial_x8..x8] == initial_wdrs[initial_x8..x8];
    reads
        wmem;

    modifies
        fgroups;
        x8; x12; x13; x16;
        wdrs; w24; w29; w30;

    ensures
        selection == get_cf1(fgroups);

        x8 == initial_x8 + i + 1;
        x16 == initial_x16 + 32 * (i + 1);
        x12 == 30;
        x13 == 24;

        wdrs[x8..final_x8] == initial_wdrs[x8..final_x8];

        forall(i:int) 0 <= i < num_words
            ==> valid_wmem_addr(wmem, initial_x16 + 32 * i);

        selection ==>
            tuple(wdrs[initial_x8 ..x8], bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(initial_wdrs[initial_x8..x8], wmem_seq(wmem, initial_x16, i+1));

        !selection ==>
            wdrs[initial_x8..x8] == initial_wdrs[initial_x8..x8];
{
    ghost var widx := x8;

    /* load limb of subtrahend (input B) to w24 */
    bn_lid_safe(x13, false, 0, x16, true);
    assert w24 == wmem[initial_x16 + 32 * i];

    /* load limb of minuend (input C) to w30 */
    bn_movr(x12, false, x8, false);
    assert w30 == wdrs[widx];

    /* perform subtraction for a limb */
    bn_subb(w29, w30, w24, false, 0, 0);

    /* conditionally select subtraction result or unmodified limb */
    bn_sel(w24, w29, w30, 1, 0);

    /* store selection result in reg file */
    bn_movr(x8, true, x13, false);

    ghost if (selection) {
        ghost var x := initial_wdrs[widx];
        ghost var z := wdrs[widx];
        
        ghost var xs := initial_wdrs[initial_x8..widx];
        ghost var zs := old(wdrs[initial_x8..widx]);

        assert initial_wdrs[initial_x8.. x8] == seq_append(xs, x);
        assert wdrs[initial_x8.. x8] == seq_append(zs, z);
    } else {
        calc == {
            wdrs[initial_x8..x8];
            ==
            seq_append(wdrs[initial_x8..widx], wdrs[widx]);
            == { assert wdrs[initial_x8..widx] == initial_wdrs[initial_x8..widx]; }
            seq_append(initial_wdrs[initial_x8..widx], wdrs[widx]);
            == { assert wdrs[widx] == initial_wdrs[widx]; }
            seq_append(initial_wdrs[initial_x8..widx], initial_wdrs[widx]);
            ==
            initial_wdrs[initial_x8..x8];
        }
    }

}

/**
 * Constant time conditional bigint subtraction
 *
 * Returns C <= C-s*B
 *         with B being a bigint of length 256..4096 bit
 *              C being a bigint of length 256..4096 bit
 *              s being a boolean value [0,1]
 *
 * Depending on state of FG1.C subtracts a bigint B located in dmem from
 * another bigint C, located in the wide reg file and stores result at same
 * position in wide reg file.
 *
 * Flags: When leaving this subroutine, flags of FG0 depend on a
 *        potentially discarded value and therefore are not usable after
 *        return. FG1 is not modified in this subroutine.
 *
 * @param[in]  x16: dmem pointer to first limb of subtrahend (B)
 * @param[in]  x8: regfile pointer to first limb of minuend and result (C)
 * @param[in]  FG.C: s, subtraction flag, subtract if 1
 * @param[in]  x30: number of limbs
 * @param[in]  FG0.C: needs to be set to 0
 *
 * clobbered registers: x8, x16, w24, w29, w30, w[x8] to w[x8+N-1]
 * clobbered Flag Groups: FG0
 */

procedure cond_sub_to_reg(ghost num_words: nat, ghost selection: bool)
    requires
        selection == get_cf1(fgroups);
        num_words == x31;
        num_words <= 12;
        x8 < 12;

        x16 < 0xfffffe60;
        forall(i:int) 0 <= i < num_words
            ==> valid_wmem_addr(wmem, x16 + 32 * i);

        get_cf0(fgroups) == false;

    reads
        x31; wmem;

    modifies
        fgroups;
        x8; x12; x13; x16;
        wdrs; w24; w29; w30;
{
    /* load pointers to temp regs */
    li(x12, 30);
    li(x13, 24);

    ghost var i: nat := 0;
    ghost var initial_wdrs := wdrs;
    ghost var initial_x8 := x8;
    ghost var final_x8 := x8 + num_words;
    ghost var initial_x16 := x16;

    lemma_empty_seq_subb();

    /* iterate over all limbs for conditional limb-wise subtraction */
    while (Loop(x31))
        invariant i + loop_ctr == num_words;

        invariant selection == get_cf1(fgroups);
        invariant num_words <= 12;
        invariant final_x8 == initial_x8 + num_words;
        invariant final_x8 < 24;

        invariant x8 == initial_x8 + i;
        invariant x16 == initial_x16 + 32 * i;
        invariant x12 == 30;
        invariant x13 == 24;

        invariant wdrs[x8..final_x8] == initial_wdrs[x8..final_x8];

        invariant initial_x16 < 0xfffffe60;
        invariant forall(i:int) 0 <= i < num_words
            ==> valid_wmem_addr(wmem, initial_x16 + 32 * i);

        invariant selection ==>
            tuple(wdrs[initial_x8..x8], bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(initial_wdrs[initial_x8..x8], wmem_seq(wmem, initial_x16, i));

        invariant !selection ==>
            wdrs[initial_x8..x8] == initial_wdrs[initial_x8..x8];

        decreases loop_ctr;
    {
        cond_sub_to_reg_inner(initial_wdrs, initial_x8, final_x8, initial_x16, num_words, selection, i);
        i := i + 1;
    }
    // ret
}


#verbatim
}
#endverbatim
