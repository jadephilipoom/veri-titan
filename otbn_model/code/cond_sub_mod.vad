include "decls.vad"

#verbatim
include "../code/vale.dfy"
include "../spec/vt_ops.dfy"

include "decls.dfy"

module cond_sub_mod {

import opened bv_ops
import opened vt_ops
import opened vt_types
import opened vt_consts
import opened vt_vale
import opened vt_decls

#endverbatim

procedure cond_sub_mod_0(ghost initial_wdrs: wdrs_t, ghost selection: bool, ghost iter: iter_t)
    returns (ghost next_iter: iter_t)

    requires
        selection == fgroups.fg1.cf;

        x8 == 5 + iter.index;
        x10 == 3;
        x11 == 2;

        // this bounds the number of iteration
        seq_len(iter.buff) <= 12;
        valid_wmem_addr(wmem, x16, iter);

        wdrs[x8..] == initial_wdrs[x8..];

        selection ==>
            tuple(wdrs[5..x8], bool_to_uint1(fgroups.fg0.cf))
            ==
            seq_subb(initial_wdrs[5..x8], iter.buff[..iter.index]);

        !selection ==>
            wdrs[5..x8] == initial_wdrs[5..x8];

    reads
        wmem;

    modifies
        fgroups;
        x8; x10; x11; x16;
        wdrs; w2; w3; w4;

    ensures
        fgroups.fg1.cf == selection;

        x8 == 5 + next_iter.index;
        x10 == 3;
        x11 == 2;

        next_iter.index == iter.index + 1;
        next_iter.base_addr == iter.base_addr;
        next_iter.buff == iter.buff;
        
        admissible_wmem_addr(wmem, x16, next_iter);

        wdrs[x8..] == initial_wdrs[x8..];

        selection ==> 
            tuple(wdrs[5.. x8], bool_to_uint1(fgroups.fg0.cf))
            ==
            seq_subb(initial_wdrs[5..x8], next_iter.buff[..next_iter.index]);

        !selection ==>
            wdrs[5..x8] == initial_wdrs[5..x8];
{
    ghost var widx := x8;

    next_iter := bn_lid_safe(x10, false, 0, x16, true, iter);
    bn_movr(x11, false, x8, false);

    bn_subb(w4, w2, w3, SFT_DFT, 0);

    bn_sel(w3, w4, w2, 1, 0);
    bn_movr(x8, true, x10, false);

    assert wdrs[x8..] == initial_wdrs[x8..];

    ghost if (selection) {
        ghost var x := initial_wdrs[widx];
        ghost var y := iter.buff[iter.index];
        ghost var z := wdrs[widx];
        // assert tuple(z, cout) == uint256_subb(x, y, cin);

        ghost var xs := initial_wdrs[5.. widx];
        // ghost var ys := wmem_seq(wmem, initial_x16, i);
        ghost var zs := old(wdrs[5.. x8]);
        // lemma_extend_seq_subb(xs, ys, zs, cin, cout, x, y, z);
        
        assert initial_wdrs[5.. x8] == seq_append(xs, x);
        assert wdrs[5.. x8] == seq_append(zs, z);
        assert next_iter.buff[..next_iter.index] == seq_append(iter.buff[..iter.index], y);
    } else {
        assert wdrs[widx] == initial_wdrs[widx];

        calc == {
            initial_wdrs[5.. widx + 1];
            == { assume false; /* should be trivial */ }
            seq_append(initial_wdrs[5.. widx], initial_wdrs[widx]);
            == { assert wdrs[widx] == initial_wdrs[widx]; }
            seq_append(initial_wdrs[5.. widx], wdrs[widx]);
            == { assert wdrs[5.. widx] == initial_wdrs[5.. widx]; }
            seq_append(wdrs[5.. widx], wdrs[widx]);
            ==
            wdrs[5.. widx + 1];
        }
    }
}

procedure cond_sub_mod(ghost num_words: nat, ghost selection: bool)
    // {:frame false}
    requires
        x31 == num_words;
        num_words <= 12;

        fgroups.fg0.cf == false;
        fgroups.fg1.cf == selection;

        valid_buff_addr(wmem, x16, num_words);

        w31 == 0;
    reads
        wmem; x31;

    modifies
        fgroups; 
        x8; x10; x11; x16;
        wdrs; w2; w3; w4; w31;

    ensures
        valid_buff_addr(old(wmem), old(x16), num_words);

        selection ==>
            tuple(wdrs[5..5+num_words], bool_to_uint1(fgroups.fg0.cf))
            ==
            seq_subb(old(wdrs[5..5+num_words]), old(wmem[x16]));

        !selection ==>
            wdrs[5..5+num_words] == old(wdrs)[5..5+num_words];
{
    li(x8, 5);
    li(x10, 3);
    li(x11, 2);

    bn_add(w31, w31, w31, SFT_DFT, 0);
    ghost var initial_wdrs := wdrs;
    ghost var initial_x16 := x16;

    ghost var iter := iter_cons(initial_x16, 0, wmem[x16]);
    assert valid_wmem_addr(wmem, x16, iter);

    while (Loop(x31))
        invariant iter.index + loop_ctr == num_words;
        invariant x8 == 5 + iter.index;
        invariant x10 == 3;
        invariant x11 == 2;

        invariant fgroups.fg1.cf == selection;

        invariant seq_len(iter.buff) == num_words;
        invariant iter.base_addr == initial_x16;
        invariant admissible_wmem_addr(wmem, x16, iter);

        invariant wdrs[x8..] == initial_wdrs[x8..];

        invariant selection ==>
            tuple(wdrs[5..x8], bool_to_uint1(fgroups.fg0.cf))
            ==
            seq_subb(initial_wdrs[5..x8], iter.buff[..iter.index]);

        invariant !selection ==>
            wdrs[5..x8] == initial_wdrs[5..x8];

        invariant wmem == old(wmem);
        decreases loop_ctr;
    {
        iter := cond_sub_mod_0(initial_wdrs, selection, iter);
    }

    assert iter.buff[..iter.index] == iter.buff;
}

#verbatim
}
#endverbatim
