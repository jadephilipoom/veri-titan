include "decls.vad"

#verbatim
include "../code/vale.dfy"

include "../spec/def.dfy"
include "../spec/ops.dfy"
include "../spec/types.dfy"

include "../gen/decls.dfy"

module cond_sub_mod {

import opened bignum_vale

import opened bignum_def
import opened ops
import opened types

import opened bignum_decls

#endverbatim

function seq_subb(x: seq(uint256), y: seq(uint256)) : tuple(seq(uint256), uint1) extern;

ghost procedure lemma_extend_seq_subb(
    ghost x:seq(uint256), ghost y:seq(uint256), ghost z:seq(uint256), 
    ghost cin:uint1, ghost cout:uint1,
    ghost new_x:uint256, ghost new_y:uint256, ghost new_z:uint256) extern;

ghost procedure lemma_empty_seq_subb() extern;

procedure cond_sub_mod_inner(
    ghost initial_wdrs: wdrs_t,
    ghost initial_x16: nat,
    ghost num_words: nat,
    ghost selection: bool,
    ghost i: nat)

    requires
        x8 == 5 + i;
        x10 == 3;
        x11 == 2;
        x16 == initial_x16 + 32 * i;

        initial_x16 < 0xfffffe60;
        num_words <= 12;

        i < num_words;

        wdrs[x8..] == initial_wdrs[x8..];

        forall(i:int) 0 <= i < num_words
            ==> valid_wmem_addr(wmem, initial_x16 + 32 * i);

        selection == get_cf1(fgroups);

        selection ==>
            tuple(wdrs[5..x8], bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(initial_wdrs[5..x8], wmem_seq(wmem, initial_x16, i));
        
        !selection ==>
            wdrs[5..x8] == initial_wdrs[5..x8];
    reads
        wmem;

    modifies
        fgroups;
        x8; x10; x11; x16;
        wdrs; w2; w3; w4;

    ensures
        x8 == 5 + i + 1;
        x10 == 3;
        x11 == 2;
        x16 == initial_x16 + 32 * (i + 1);

        wdrs[x8..] == initial_wdrs[x8..];

        selection == get_cf1(fgroups);

        forall(i:int) 0 <= i < num_words
            ==> valid_wmem_addr(wmem, initial_x16 + 32 * i);

        selection ==> 
            tuple(wdrs[5.. x8], bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(initial_wdrs[5..x8], wmem_seq(wmem, initial_x16, i+1));

        !selection ==>
            wdrs[5..x8] == initial_wdrs[5..x8];
{
    ghost var widx := x8;

    bn_lid_safe(x10, false, 0, x16, true);
    bn_movr(x11, false, x8, false);

    // ghost var cin := bool_to_uint1(get_cf0(fgroups));
    bn_subb(w4, w2, w3, false, 0, 0);
    // ghost var cout := bool_to_uint1(get_cf0(fgroups));

    bn_sel(w3, w4, w2, 1, 0);
    bn_movr(x8, true, x10, false);

    assert wdrs[x8..] == initial_wdrs[x8..];

    ghost if (selection) {
        ghost var x := initial_wdrs[widx];
        // ghost var y := wmem[initial_x16 + 32 * i];
        ghost var z := wdrs[widx];

        // assert tuple(z, cout) == uint256_subb(x, y, cin);

        ghost var xs := initial_wdrs[5.. widx];
        // ghost var ys := wmem_seq(wmem, initial_x16, i);
        ghost var zs := old(wdrs[5.. x8]);

    //    lemma_extend_seq_subb(
    //        xs, ys, zs,
    //        cin, cout, x, y, z);
        
        assert initial_wdrs[5.. x8] == seq_append(xs, x);
        assert wdrs[5.. x8] == seq_append(zs, z);
    } else {
        assert wdrs[widx] == initial_wdrs[widx];

        calc == {
            initial_wdrs[5.. widx + 1];
            == seq_append(initial_wdrs[5.. widx], initial_wdrs[widx]);
            == { assert wdrs[widx] == initial_wdrs[widx]; }
           seq_append(initial_wdrs[5.. widx], wdrs[widx]);
            == { assert wdrs[5.. widx] == initial_wdrs[5.. widx];}
            seq_append(wdrs[5.. widx], wdrs[widx]);
            ==
            wdrs[5.. widx + 1];
        }
    }
}

procedure cond_sub_mod(ghost num_words: nat, ghost selection: bool)
    // {:frame false}
    requires
        selection == get_cf1(fgroups);
        num_words == x31;

        x31 <= 12;
        x16 < 0xfffffe60;

        w31 == 0;

        get_cf0(fgroups) == false;

        forall(i:int) 0 <= i < x31 ==>
            valid_wmem_addr(wmem, old(x16) + 32 * i);
    reads
        wmem; x31;

    modifies
        fgroups; 
        x8; x10; x11; x16;
        wdrs; w2; w3; w4; w31;

    ensures
        forall(i:int) 0 <= i < num_words
            ==> valid_wmem_addr(wmem, old(x16) + 32 * i);

        selection ==> 
            tuple(wdrs[5..5+num_words], bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(old(wdrs)[5..5+num_words], wmem_seq(wmem, old(x16), num_words));

        !selection ==>
            wdrs[5..5+num_words] == old(wdrs)[5..5+num_words];
{
    li(x8, 5);
    li(x10, 3);
    li(x11, 2);

    bn_add(w31, w31, w31, false, 0, 0);
    ghost var i: nat := 0;
    ghost var initial_wdrs := wdrs;
    ghost var initial_x16 := x16;

    lemma_empty_seq_subb();

    while (Loop(x31))
        invariant i + loop_ctr == num_words;
        invariant x8 == 5 + i;
        invariant x10 == 3;
        invariant x11 == 2;
        invariant x16 == initial_x16 + 32 * i;

        invariant get_cf1(fgroups) == selection;

        invariant wdrs[x8..] == initial_wdrs[x8..];

        invariant forall(i:int) 0 <= i < num_words
            ==> valid_wmem_addr(wmem, initial_x16 + 32 * i);

        invariant selection ==>
            tuple(wdrs[5..x8], bool_to_uint1(get_cf0(fgroups)))
            ==
            seq_subb(initial_wdrs[5..x8], wmem_seq(wmem, initial_x16, i));
        
        invariant !selection ==>
            wdrs[5..x8] == initial_wdrs[5..x8];

        decreases loop_ctr;
    {
        cond_sub_mod_inner(initial_wdrs, initial_x16, num_words, selection, i);
        i := i + 1;
    }
}

#verbatim
}
#endverbatim
