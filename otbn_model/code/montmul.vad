include "decls.vad"
include "mont_loop.vad"

ghost procedure montmul_inv_lemma0(
       ghost a: seq(uint256),
       ghost x: seq(uint256), 
       ghost i: int,
       ghost y: seq(uint256), 
       ghost key: pub_key) extern;

#verbatim
include "../code/vale.dfy"
include "../spec/vt_ops.dfy"
include "decls.dfy"

include "mont_loop.dfy"
include "../code/mont_loop_lemmas.dfy"
include "../code/montmul_lemmas.dfy"

module montmul {

import opened bv_ops
import opened vt_ops
import opened vt_types
import opened vt_consts
import opened vt_vale
import opened vt_decls
import opened powers
import opened congruences

// import opened mul256
// import opened addc512
// import opened addc512_lemmas
// import opened cond_sub_to_reg
import opened mont_loop
import opened mont_loop_lemmas
import opened montmul_lemmas

#endverbatim

procedure montmul_0(ghost vars: mm_vars)
    returns (ghost a_slice: seq(uint256))

    {:frame false}

    requires
        x9 == 3;
        x10 == 4;
        x11 == 2;
        x30 == NUM_WORDS;
    
        w31 == 0;
        mm_vars_inv(vars, wmem, x20, x19, x16, NA, x17);

    ensures
        x11 == 2;
        x20 == old(x20);
        x30 == NUM_WORDS;
        x31 == old(x31);

        w3 == vars.key.m0d;
        w31 == 0;

        wmem == old(wmem);

        valid_wdr_view(wdrs, a_slice, 4, NUM_WORDS);
        mm_vars_inv(vars, wmem, x20, x19, x16, NA, x17);
{
    let _ := bn_lid_safe(x9, false, 0, x17, false, vars.m0d_iter);
    bn_mov(w2, w31);

    a_slice := wdrs[4..4+NUM_WORDS];

    while (Loop(x30))
        invariant
            x10 + loop_ctr == 4 + NUM_WORDS;
            x11 == 2;
            x20 == old(x20);
            x30 == NUM_WORDS;
            x31 == old(x31);

            w2 == 0;
            w3 == vars.key.m0d;
            w31 == 0;

            mm_vars_inv(vars, wmem, x20, x19, x16, NA, x17);
            valid_wdr_view(wdrs, a_slice, 4, NUM_WORDS);
            
            wmem == old(wmem);

        decreases loop_ctr;
    {
        let index := x10 - 4;
        a_slice := a_slice[index := 0];
        let prev_wdrs := wdrs;
        bn_movr(x10, true, x11, false);
        assert wdrs == prev_wdrs[4 + index := 0];
    }
}

procedure montmul(ghost vars: mm_vars)
    {:frame false}

    requires
        x9 == 3;
        x10 == 4;
        x11 == 2;
    
        x30 == NUM_WORDS;
        x31 == NUM_WORDS - 1;

        mm_vars_inv(vars, wmem, x20, x19, x16, NA, x17);

        w31 == 0;
{
    ghost var a_slice: seq(uint256);

    a_slice := montmul_0(vars);
    assume to_nat(a_slice) == 0;

    ghost var x_iter := vars.x_iter;

    assert montmul_inv(a_slice, x_iter.buff, x_iter.index, vars.y_iter.buff, vars.key) by {
        montmul_inv_lemma0(a_slice, x_iter.buff, x_iter.index, vars.y_iter.buff, vars.key);
    }

    while (Loop(x30))
        invariant
            x11 == 2;
            x30 == NUM_WORDS;
            x31 == NUM_WORDS - 1;

            iter_inv(wmem, x20, x_iter);
            // seq_len(x_iter.buff) == NUM_WORDS;
            x_iter.index + loop_ctr == NUM_WORDS;
            x_iter.base_addr == vars.x_iter.base_addr;

            w3 == vars.key.m0d;
            w31 == 0;
    
            mm_vars_inv(vars, wmem, NA, x19, x16, NA, x17);
            montmul_inv(a_slice, x_iter.buff, x_iter.index, vars.y_iter.buff, vars.key);

            valid_wdr_view(wdrs, a_slice, 4, NUM_WORDS);

            wmem == old(wmem);

        decreases loop_ctr;
    {
        x_iter := bn_lid_safe(x11, false, 0, x20, true, x_iter);
        addi(x6, x16, 0);
        addi(x7, x19, 0);

        a_slice := mont_loop(x_iter, w2, vars.y_iter, vars.m_iter, a_slice, vars.key);

        addi(x16, x6, 0);
        addi(x19, x7, 0);
    }
}


#verbatim
}
#endverbatim
