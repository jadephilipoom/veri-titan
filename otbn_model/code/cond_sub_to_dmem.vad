include "decls.vad"

#verbatim
include "../code/vale.dfy"
include "../spec/vt_ops.dfy"
include "../gen/decls.dfy"

module cond_sub_to_dmem {

import opened bv_ops
import opened vt_ops
import opened vt_types
import opened vt_consts
import opened vt_vale
import opened vt_decls

#endverbatim
 
procedure cond_sub_to_dmem_inner(
    ghost initial_x8: uint32,
    ghost initial_buff: seq(uint256),
    ghost iter: iter_t,
    ghost num_words: nat,
    ghost selection: bool)

    returns (ghost next_iter: iter_t)

    requires
        x8 == initial_x8 + iter.index;
        x9 == 3;
        x11 == 2;

        // TODO: extend to none-aliasing case
        // for now the use cases suggest they should alias
        valid_wmem_addr(wmem, x16, iter);
        valid_wmem_addr(wmem, x21, iter);

        0 < num_words <= 12;
        seq_len(initial_buff) == num_words;
        seq_len(iter.buff) == num_words;
        initial_buff[iter.index..] == iter.buff[iter.index..];

        4 <= x8 < 31;
        4 <= initial_x8 < 10;

        selection == fgroups.fg1.cf;

        selection ==>
            tuple(iter.buff[..iter.index], bool_to_uint1(fgroups.fg0.cf))
            ==
            seq_subb(wdrs[initial_x8..x8], initial_buff[..iter.index]);
        
        !selection ==>
            iter.buff[..iter.index] == wdrs[initial_x8..x8];

    modifies
        x8; x9; x11; x16; x21;
        w2; w3;
        fgroups; wdrs; wmem;

    ensures
        x8 == initial_x8 + next_iter.index;
        x9 == 3;
        x11 == 2;

        4 <= x8 < 31;

        seq_len(next_iter.buff) == num_words;
        admissible_wmem_addr(wmem, x16, next_iter);
        admissible_wmem_addr(wmem, x21, next_iter);

        next_iter.index == iter.index + 1;
        next_iter.base_addr == iter.base_addr;

        initial_buff[next_iter.index..] == next_iter.buff[next_iter.index..];

        selection == fgroups.fg1.cf;

        wdrs[initial_x8..] == old(wdrs[initial_x8..]);

        selection ==>
            tuple(next_iter.buff[..next_iter.index], bool_to_uint1(fgroups.fg0.cf))
            ==
            seq_subb(wdrs[initial_x8..x8], initial_buff[..next_iter.index]);

        !selection ==>
            next_iter.buff[..next_iter.index] == wdrs[initial_x8..x8];    
{
    ghost var widx := x8;
    ghost var midx := iter.index;

    /* load limb of subtrahend (input B): w3 = dmem[x16+i] */
    let _ := bn_lid_safe(x9, false, 0, x16, true, iter);

    /* move limb from bignum bufer to w2 */
    bn_movr(x11, false, x8, true);

    /* perform subtraction for a limb w3 = w3 - w2 */
    bn_subb(w3, w2, w3, false, 0, 0);

    /* conditionally select subtraction result or unmodified limb */
    bn_sel(w2, w3, w2, 1, 0);

    /* store selection result in dmem */
    next_iter := bn_sid_safe(x11, false, 0, x21, true, iter);

    assert wdrs[initial_x8..] == old(wdrs[initial_x8..]);

    ghost if (selection) {
        ghost var x := wdrs[widx];
        ghost var y := iter.buff[midx];
        ghost var z := next_iter.buff[midx];

        ghost var xs := wdrs[initial_x8..widx];
        ghost var ys := initial_buff[..midx];
        ghost var zs := iter.buff[..midx];

        assert wdrs[initial_x8..x8] == seq_append(xs, x);
        assert initial_buff[..next_iter.index] == seq_append(ys, y);
        assert next_iter.buff[..next_iter.index] == seq_append(zs, z);
    } else {
        calc == {
            next_iter.buff[..next_iter.index];
            ==
            seq_append(next_iter.buff[..midx], next_iter.buff[midx]);
            ==
            seq_append(iter.buff[..midx], next_iter.buff[midx]);
            == { assert iter.buff[..midx] == wdrs[initial_x8..widx]; }
            seq_append(wdrs[initial_x8..widx], next_iter.buff[midx]);
            == { assert next_iter.buff[midx] == wdrs[widx]; }
            seq_append(wdrs[initial_x8..widx], wdrs[widx]);
            ==
            wdrs[initial_x8..widx+1];
        }
        assert next_iter.buff[..next_iter.index] == wdrs[initial_x8..x8];    
    }
}

procedure cond_sub_to_dmem(ghost num_words: nat, ghost selection: bool)
    requires
        x9 == 3;
        x11 == 2;

        4 <= x8 < 10;

        x30 == num_words;
        x30 <= 12;

        fgroups.fg0.cf == false;
        fgroups.fg1.cf == selection;

        // TODO: extend to none-aliasing case
        // for now the use cases suggest they should alias
        x21 == x16;
        valid_buff_addr(wmem, x16, num_words);

    reads
        x30;

    modifies
        x8; x9; x11; x16; x21;
        w2; w3;
        fgroups; wdrs; wmem;

    ensures
        valid_buff_addr(wmem, old(x16), num_words);
        valid_buff_addr(old(wmem), old(x16), num_words);

        selection ==>
            tuple(wmem[old(x16)], bool_to_uint1(fgroups.fg0.cf))
            ==
            seq_subb(old(wdrs[x8..x8+num_words]), old(wmem[x16]));
        
        !selection ==>
            wmem[old(x16)] == old(wdrs[x8..x8+num_words]);
{
    ghost var iter := iter_cons(x16, 0, wmem[x16]);
    ghost var initial_x8 := x8;
    ghost var initial_buff := iter.buff;

    while (Loop(x30))
        invariant iter.index + loop_ctr == num_words;
        invariant x8 == initial_x8 + iter.index;
        invariant x9 == 3;
        invariant x11 == 2;

        // TODO: extend to none-aliasing case
        // for now the use cases suggest they should alias
        invariant admissible_wmem_addr(wmem, x16, iter);
        invariant admissible_wmem_addr(wmem, x21, iter);
        invariant seq_len(iter.buff) == num_words;
        invariant initial_buff[iter.index..] == iter.buff[iter.index..];
        invariant iter.base_addr == old(x16);

        invariant 4 <= x8 < 31;

        invariant selection == fgroups.fg1.cf;

        invariant wdrs[initial_x8..] == old(wdrs[initial_x8..]);

        invariant selection ==>
            tuple(iter.buff[..iter.index], bool_to_uint1(fgroups.fg0.cf))
            ==
            seq_subb(wdrs[initial_x8..x8], initial_buff[..iter.index]);
        
        invariant !selection ==>
            iter.buff[..iter.index] == wdrs[initial_x8..x8];

        decreases loop_ctr;
    {
        iter := cond_sub_to_dmem_inner(initial_x8, initial_buff, iter, num_words, selection);
    }

    assert initial_buff[..iter.index] == initial_buff;
    assert iter.buff[..iter.index] == iter.buff;
    assert iter.buff == wmem[old(x16)];
    assert old(wdrs[x8..x8+num_words]) == wdrs[initial_x8..initial_x8+num_words];
}

#verbatim
}
#endverbatim
