include "decls.vad"
include "montmul.vad"

#verbatim
include "../code/vale.dfy"
include "../spec/rsa_ops.dfy"
include "decls.dfy"

include "montmul.dfy"
// include "../code/mont_loop_lemmas.dfy"
// include "../code/montmul_lemmas.dfy"

module modexp_var {

import opened bv_ops
import opened vt_ops
import opened rsa_ops
import opened vt_consts
import opened vt_vale
import opened vt_decls
import opened powers
import opened congruences

import opened mont_loop
import opened montmul
import opened mont_loop_lemmas
// import opened montmul_lemmas

#endverbatim

procedure compute_m0inv(ghost vars: mm_vars)
    requires
        mm_vars_safe(vars, wmem, NA, NA, NA, NA, x17);

    modifies
        fgroups; wmem;
        x8; x17; w0; w1; w28; w29;
    
    reads
        xmem; x16;

    ensures
        x17 == old(17);
        mm_vars_safe(vars, wmem, NA, NA, NA, NA, x17);
        wmem == old(wmem)[x17 := seq(vars.key.m0d)];
{
    assume false;
}

procedure compute_rr(ghost vars: mm_vars)
    {: frame false}

    requires
        mm_vars_safe(vars, wmem, NA, NA, x16, x18, x17);
        to_nat(vars.m_iter.buff) == vars.key.m;
        vars.m0d_iter.buff[0] == vars.key.m0d;

    ensures
        x16 == old(16);
        x18 == old(18);
        x17 == old(17);
        x30 == old(x30);
        x31 == old(x31);

        w31 == old(w31);

        mm_vars_safe(vars, wmem, NA, NA, x16, x18, x17);
        to_nat(vars.m_iter.buff) == vars.key.m;
        to_nat(vars.m0d_iter.buff) == vars.key.m0d;
        to_nat(vars.rr_iter.buff) == vars.key.RR;

        wmem == old(wmem)[x18 := wmem[x18]];
        xmem == old(xmem);
{
    assume false;
}

procedure modexp_var_0(ghost initial_vars: mm_vars)
    returns (ghost vars: mm_vars)

    {:frame false}

    requires
        valid_xmem_addr(xmem, 4);
        xmem[4] == NUM_WORDS;

        valid_xmem_addr(xmem, 8);  // m0d
        valid_xmem_addr(xmem, 12); // rr
        valid_xmem_addr(xmem, 16); // m
        valid_xmem_addr(xmem, 20); // sig

        mm_vars_safe(initial_vars, wmem, NA, xmem[20], xmem[16], xmem[12], xmem[8]);
        to_nat(initial_vars.m_iter.buff) == initial_vars.key.m;

        xmem[20] != xmem[8];
        xmem[20] != xmem[12];

    ensures
        x30 == NUM_WORDS;
        x31 == NUM_WORDS - 1;

        w31 == 0;

        xmem == old(xmem); 
        mm_vars_inv(vars, wmem, NA, xmem[20], x16, x18, x17);
        wmem == old(wmem)[x17 := seq(vars.key.m0d)][x18 := wmem[x18]];

{
    vars := initial_vars;

    bn_xor(w31, w31, w31, SFT_DFT);
    assume w31 == 0;

    lw(x30, 4, x0);

    addi(x31, x0, 1); // TODO: use one instruction instead
    sub(x31, x30, x31);

    lw(x16, 16, x0);

    lw(x17, 8, x0);

    lw(x18, 12, x0);

    // TODO: figure out if these will be pre-computed
    compute_m0inv(vars);
    compute_rr(vars);

    // TODO: it is easier to restore pointers in the procedures
    // lw        x16, 16(x0)
    // lw        x17, 8(x0)
    // lw        x18, 12(x0)
}

procedure write_to_dmem(ghost iter: iter_t)
    returns (ghost out_iter: iter_t)

    requires
        x8 == 4;
        x30 == NUM_WORDS;

        iter_safe(iter, wmem, x21);
        seq_len(iter.buff) == NUM_WORDS;
        iter.index == 0;
    
    modifies
        x8; x21; x30; wdrs; wmem;

{
    out_iter := iter;
    // slice := wdrs[4..4+NUM_WORDS];

    while (Loop(x30))
        invariant
            x8 == 4 + out_iter.index;

            iter_inv(out_iter, wmem, x21);
            out_iter.index + loop_ctr == NUM_WORDS;
            seq_len(out_iter.buff) == NUM_WORDS;
            // valid_wdr_view(wdrs, out_iter.buff, 4, out_iter.index);

        decreases
            loop_ctr;
    {
        out_iter := bn_sid_safe(x8, false, 0, x21, true, out_iter);
        addi(x8, x8, 1);
    }
}

procedure modexp_var(ghost initial_vars: mm_vars)

    {:frame false}
    
    requires
        valid_xmem_addr(xmem, 4);
        xmem[4] == NUM_WORDS;

        valid_xmem_addr(xmem, 8);  // m0d
        valid_xmem_addr(xmem, 12); // rr
        valid_xmem_addr(xmem, 16); // m
        valid_xmem_addr(xmem, 20); // sig
        valid_xmem_addr(xmem, 28); // out

        mm_vars_safe(initial_vars, wmem, NA, xmem[20], xmem[16], xmem[12], xmem[8]);
        to_nat(initial_vars.m_iter.buff) == initial_vars.key.m;

        xmem[20] != xmem[8];
        xmem[20] != xmem[12];
{
    ghost var vars: mm_vars;
    ghost var sig_slice: seq(uint256);

    vars := modexp_var_0(initial_vars);

    li(x8, 4);
    li(x9, 3);
    li(x10, 4);
    li(x11, 2);

    lw(x19, 20, x0);
    addi(x20, x18, 0);
    lw(x21, 28, x0);

    let sig_iter := iter_cons(x19, 0, wmem[x19]);
    let rr_iter := iter_cons(x20, 0, wmem[x20]);

    // assert rr_iter == vars.rr_iter;
    vars := vars.(x_iter := rr_iter).(y_iter := sig_iter);
    assert mm_vars_inv(vars, wmem, x20, x19, x16, x18, x17);

    sig_slice := montmul(vars);
    assert montmul_inv(sig_slice, rr_iter.buff, NUM_WORDS, sig_iter.buff, vars.key);
    assert rr_iter.buff == rr_iter.buff[..NUM_WORDS];
    assert cong(to_nat(sig_slice) * vars.key.R, to_nat(rr_iter.buff) * to_nat(sig_iter.buff), vars.key.m);
    
}


#verbatim
}
#endverbatim
