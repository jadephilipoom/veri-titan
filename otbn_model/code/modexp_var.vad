include "decls.vad"
include "montmul.vad"

#verbatim
include "montmul.dfy"
include "../code/modexp_var_lemmas.dfy"

module modexp_var {

import opened bv_ops
import opened vt_ops
import opened rsa_ops
import opened vt_consts
import opened vt_vale
import opened vt_decls
import opened powers
import opened congruences

import opened mont_loop
import opened montmul
import opened mont_loop_lemmas
import opened modexp_var_lemmas

#endverbatim

function modexp_var_inv(a: nat, sig: nat, i: nat, key: pub_key): bool extern;

ghost procedure modexp_var_inv_lemma_0(
    ghost a_slice: seq(uint256),
    ghost rr: seq(uint256),
    ghost sig: seq(uint256),
    ghost key: pub_key) extern;

ghost procedure modexp_var_inv_lemma_1(
    ghost a_slice: seq(uint256),
    ghost next_a_slice: seq(uint256),
    ghost sig: nat,
    ghost i: nat,
    ghost key: pub_key) extern;

ghost procedure modexp_var_inv_lemma_2(
    ghost a_slice: seq(uint256),
    ghost next_a_slice: seq(uint256),
    ghost sig: seq(uint256),
    ghost key: pub_key)  extern;

procedure compute_m0inv(ghost vars: mm_vars)
    requires
        mm_vars_safe(vars, wmem, NA, NA, NA, NA, x17);

    modifies
        fgroups; wmem;
        x8; x17; w0; w1; w28; w29;
    
    reads
        xmem; x16;

    ensures
        x17 == old(17);
        mm_vars_safe(vars, wmem, NA, NA, NA, NA, x17);
        wmem == old(wmem)[x17 := seq(vars.key.m0d)];
{
    assume false;
}

procedure compute_rr(ghost vars: mm_vars)
    {: frame false}

    requires
        mm_vars_safe(vars, wmem, NA, NA, x16, x18, x17);
        to_nat(vars.m_iter.buff) == vars.key.m;
        vars.m0d_iter.buff[0] == vars.key.m0d;

    ensures
        x16 == old(16);
        x18 == old(18);
        x17 == old(17);
        x29 == old(x29);
        x30 == old(x30);
        x31 == old(x31);

        w31 == old(w31);

        mm_vars_safe(vars, wmem, NA, NA, x16, x18, x17);
        to_nat(vars.m_iter.buff) == vars.key.m;
        to_nat(vars.m0d_iter.buff) == vars.key.m0d;
        to_nat(vars.rr_iter.buff) == vars.key.RR;

        wmem == old(wmem)[x18 := wmem[x18]];
        xmem == old(xmem);
{
    assume false;
}

procedure modexp_var_0(ghost vars: mm_vars)

    {:frame false}

    requires

        valid_xmem_addr(xmem, 0);  // e'
        xmem[0] == vars.key.e';

        valid_xmem_addr(xmem, 4);
        xmem[4] == NUM_WORDS;

        valid_xmem_addr(xmem, 8);  // m0d
        valid_xmem_addr(xmem, 12); // rr
        valid_xmem_addr(xmem, 16); // m
        valid_xmem_addr(xmem, 20); // sig

        mm_vars_safe(vars, wmem, NA, xmem[20], xmem[16], xmem[12], xmem[8]);
        to_nat(vars.m_iter.buff) == vars.key.m;

        xmem[20] != xmem[8];
        xmem[20] != xmem[12];

    ensures
    
        x29 == vars.key.e';
        x30 == NUM_WORDS;
        x31 == NUM_WORDS - 1;

        w31 == 0;

        xmem == old(xmem); 
        mm_vars_inv(vars, wmem, NA, xmem[20], x16, x18, x17);
        wmem == old(wmem)[x17 := seq(vars.key.m0d)][x18 := wmem[x18]];

{
    bn_xor(w31, w31, w31, SFT_DFT);
    assume w31 == 0;

    lw(x30, 4, x0);

    addi(x31, x0, 1); // TODO: use one instruction instead
    sub(x31, x30, x31);

    lw(x16, 16, x0);

    lw(x17, 8, x0);

    lw(x18, 12, x0);

    lw(x29, 0, x0);

    // TODO: figure out if these will be pre-computed
    compute_m0inv(vars);
    compute_rr(vars);

    // TODO: it is easier to restore pointers in the procedures
    // lw        x16, 16(x0)
    // lw        x17, 8(x0)
    // lw        x18, 12(x0)
}

procedure write_to_dmem(ghost iter: iter_t)
    returns (ghost next_iter: iter_t)

    requires
        x8 == 4;
        x30 == NUM_WORDS;

        iter_safe(iter, wmem, x21);
        seq_len(iter.buff) == NUM_WORDS;
        iter.index == 0;
    
    modifies
        x8; x21; wmem;
    
    reads
        x30; wdrs;

    ensures
        iter_inv(next_iter, wmem, iter.base_addr);
        next_iter.base_addr == iter.base_addr;
        seq_len(next_iter.buff) == NUM_WORDS;
        next_iter.buff == wdrs[4..4+NUM_WORDS];
        iter.index == 0;

        wmem == old(wmem)[next_iter.base_addr := next_iter.buff];
{
    next_iter := iter;

    while (Loop(x30))
        invariant
            x8 == 4 + next_iter.index;

            iter_inv(next_iter, wmem, x21);
            next_iter.index + loop_ctr == NUM_WORDS;
            seq_len(next_iter.buff) == NUM_WORDS;

            next_iter.buff[..next_iter.index] == wdrs[4..4+next_iter.index];
            wdrs == old(wdrs);

            next_iter.base_addr == iter.base_addr;
            wmem == old(wmem)[next_iter.base_addr := next_iter.buff];

        decreases
            loop_ctr;
    {   
        ghost var index := next_iter.index;
        ghost var last_iter := next_iter;

        next_iter := bn_sid_safe(x8, false, 0, x21, true, next_iter);
        addi(x8, x8, 1);

        assert next_iter.buff[index] == wdrs[4+index];
    }

    next_iter := next_iter.(index := 0);
}

procedure modexp_var(
    ghost initial_vars: mm_vars)

    {:frame false}
    
    requires
        valid_xmem_addr(xmem, 0);  //
        xmem[0] == initial_vars.key.e';

        valid_xmem_addr(xmem, 4);
        xmem[4] == NUM_WORDS;

        valid_xmem_addr(xmem, 8);  // m0d
        valid_xmem_addr(xmem, 12); // rr
        valid_xmem_addr(xmem, 16); // m
        valid_xmem_addr(xmem, 20); // sig
        valid_xmem_addr(xmem, 28); // out

        mm_vars_safe(initial_vars, wmem, NA, xmem[20], xmem[16], xmem[12], xmem[8]);
        
        valid_wmem_base_addr(wmem, xmem[28], NUM_WORDS);

        to_nat(initial_vars.m_iter.buff) == initial_vars.key.m;

        xmem[20] != xmem[8];
        xmem[20] != xmem[12];

        xmem[28] != xmem[8];
        xmem[28] != xmem[12];
        xmem[28] != xmem[16];
        xmem[28] != xmem[20];
{
    ghost var a_slice: seq(uint256);
    
    modexp_var_0(initial_vars);

    li(x8, 4);
    li(x9, 3);
    li(x10, 4);
    li(x11, 2);

    lw(x19, 20, x0);
    addi(x20, x18, 0);
    lw(x21, 28, x0);

    let sig_iter := iter_cons(x19, 0, wmem[x19]);
    let rr_iter := iter_cons(x20, 0, wmem[x20]);

    ghost var vars := initial_vars.(x_iter := rr_iter).(y_iter := sig_iter);
    a_slice := montmul(vars);

    let out_addr := xmem[28];
    ghost var out_iter := iter_cons(out_addr, 0, wmem[out_addr]);
    out_iter := write_to_dmem(out_iter);

    vars := vars.(x_iter := out_iter).(y_iter := out_iter);

    modexp_var_inv_lemma_0(a_slice, rr_iter.buff, sig_iter.buff, vars.key);

    ghost var i : nat := 0;

    assert x29 == vars.key.e';

    while (Loop(x29))
        invariant
            x9 == 3;
            x10 == 4;
            x11 == 2;
        
            x30 == NUM_WORDS;
            x31 == NUM_WORDS - 1;

            w31 == 0;

            mm_iter_inv(sig_iter, wmem, sig_iter.base_addr);
            valid_xmem_addr(xmem, 20);
            xmem[20] == sig_iter.base_addr;

            valid_xmem_addr(xmem, 28);
            xmem[28] == out_addr;

            iter_safe(out_iter, wmem, out_addr);
            seq_len(out_iter.buff) == NUM_WORDS;
            out_iter.index == 0;
            out_iter.buff == a_slice;

            mm_vars_inv(vars, wmem, out_addr, out_addr, x16, NA, x17);
            modexp_var_inv(to_nat(a_slice), to_nat(sig_iter.buff), i, vars.key);

            out_addr != x16;
            out_addr != x17;

            i + loop_ctr == vars.key.e'; 

        decreases
            loop_ctr;
    {
        lw(x19, 28, x0);
        lw(x20, 28, x0);
        lw(x21, 28, x0);

        let prev_a_slice := a_slice;
        a_slice := montmul(vars);

        out_iter := write_to_dmem(out_iter);
        
        vars := vars.(x_iter := out_iter).(y_iter := out_iter);

        modexp_var_inv_lemma_1(prev_a_slice, a_slice, to_nat(sig_iter.buff), i, vars.key);
    
        i := i + 1;
    }

    lw(x19, 20, x0);
    lw(x20, 28, x0);
    lw(x21, 28, x0);
    let prev_a_slice := a_slice;

    vars := vars.(x_iter := out_iter).(y_iter := sig_iter);
    a_slice := montmul(vars);

    modexp_var_inv_lemma_2(prev_a_slice, a_slice, sig_iter.buff, vars.key);
}


#verbatim
}
#endverbatim
