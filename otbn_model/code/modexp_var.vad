include "decls.vad"
include "montmul.vad"

#verbatim
include "../code/vale.dfy"
include "../spec/rsa_ops.dfy"
include "decls.dfy"

include "montmul.dfy"
// include "../code/mont_loop_lemmas.dfy"
// include "../code/montmul_lemmas.dfy"

module modexp_var {

import opened bv_ops
import opened vt_ops
import opened rsa_ops
import opened vt_consts
import opened vt_vale
import opened vt_decls
import opened powers
import opened congruences

import opened mont_loop
import opened montmul
import opened mont_loop_lemmas
// import opened montmul_lemmas

#endverbatim

procedure compute_m0inv(ghost vars: mm_vars)
    requires
        mm_vars_inv(vars, wmem, NA, NA, x16, NA, NA);
        valid_wmem_base_addr(wmem, x17, 1);

    modifies
        fgroups; wmem;
        x8; x17; w0; w1; w28; w29;
    
    reads
        xmem; x16;

    ensures
        x17 == old(17);
        mm_vars_inv(vars, wmem, NA, NA, x16, NA, x17);
        wmem == old(wmem)[x17 := seq(vars.key.m0d)];
{
    assume false;
}

procedure compute_rr(ghost vars: mm_vars)
    {: frame false}

    requires
        mm_vars_inv(vars, wmem, NA, NA, x16, NA, x17);
        valid_wmem_base_addr(wmem, x18, NUM_WORDS);

    ensures
        x16 == old(16);
        x18 == old(18);
        x17 == old(17);
        x30 == old(x30);
        x31 == old(x31);

        w31 == old(w31);

        mm_vars_inv(vars, wmem, NA, NA, x16, x18, x17);
        wmem == old(wmem)[x18 := wmem[x18]];
        xmem == old(xmem);
{
    assume false;
}

procedure modexp_var_0(ghost vars: mm_vars)
    returns (ghost msig: seq(uint256))

    {:frame false}

    requires
        valid_xmem_addr(xmem, 4);
        xmem[4] == NUM_WORDS;

        valid_xmem_addr(xmem, 16); // m

        valid_xmem_addr(xmem, 8);  // m0d
        valid_wmem_base_addr(wmem, xmem[8], 1);

        valid_xmem_addr(xmem, 12); // rr
        valid_wmem_base_addr(wmem, xmem[12], NUM_WORDS);

        valid_xmem_addr(xmem, 20); // sig
        valid_wmem_base_addr(wmem, xmem[20], NUM_WORDS);

        valid_xmem_addr(xmem, 28); // output
        valid_wmem_base_addr(wmem, xmem[28], NUM_WORDS);

        xmem[20] != xmem[8];
        xmem[20] != xmem[12];

        mm_vars_inv(vars, wmem, NA, NA, xmem[16], NA, NA);

    ensures
        // x30 == NUM_WORDS;
        // x31 == NUM_WORDS - 1;
        // mm_vars_inv(vars, wmem, NA, NA, x16, x18, x17);
{
    ghost var mvars := vars;

    bn_xor(w31, w31, w31, SFT_DFT);
    assume w31 == 0;

    lw(x30, 4, x0);

    addi(x31, x0, 1); // TODO: use one instruction instead
    sub(x31, x30, x31);

    lw(x16, 16, x0);

    lw(x17, 8, x0);

    lw(x18, 12, x0);

    // TODO: figure out if these will be pre-computed
    compute_m0inv(mvars);
    compute_rr(mvars);

    assert valid_wmem_base_addr(wmem, xmem[20], NUM_WORDS);

    // TODO: it is easier to restore pointers in the procedures
    // lw        x16, 16(x0)
    // lw        x17, 8(x0)
    // lw        x18, 12(x0)

    li(x8, 4);
    li(x9, 3);
    li(x10, 4);
    li(x11, 2);

    lw(x19, 20, x0);
    lw(x20, 12, x0);
    lw(x21, 28, x0);

    let sig_iter := iter_cons(x19, 0, wmem[x19]);
    let rr_iter := iter_cons(x20, 0, wmem[x20]);
    // assert iter_inv(sig_iter, wmem, x19);
    // assert iter_inv(rr_iter, wmem, x20);
    mvars := mvars.(x_iter := rr_iter).(y_iter := sig_iter);

    assert mm_vars_inv(mvars, wmem, x20, x19, x16, x18, x17);
    msig := montmul(mvars);
    assert montmul_inv(msig, mvars.x_iter.buff, NUM_WORDS, mvars.y_iter.buff, mvars.key);
    // assert cong(to_nat(msig) * pow_B256(NUM_WORDS), to_nat(sig_iter.buff[..NUM_WORDS]) * to_nat(rr_iter.buff), mvars.key.m);
}

procedure modexp_var(ghost vars: mm_vars)
//     {:frame false}

{


//     // /* convert signature to Montgomery domain
//     //     out_buf = *x28 = *dmem[28]
//     //         <- montmul(*x19, *x20) = montmul(*dptr_sig, *dptr_rr) = sig*R mod M */
//     // lw(x19, 20, x0);
//     // lw(x20, 12, x0);
//     // lw(x21, 28, x0);

//     // assume mm_vars_inv(vars, wmem, x20, x19, x16, NA, x17);

//     // let a_slice := montmul(vars);
// //   /* store result in dmem starting at dmem[dptr_out] */
// //   loop      x30, 2
// //     bn.sid    x8, 0(x21++)
// //     addi      x8, x8, 1
}



#verbatim
}
#endverbatim
