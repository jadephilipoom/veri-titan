include{: verbatim} "../../arch/riscv/vale.i.dfy"

#verbatim
module rv_decls {
import opened bv_ops
import opened rv_machine
import opened rv_vale

// import opened rsa_ops
#endverbatim

type seq(a: Type(0)): Type(0) {: primitive} extern;
function operator([]) #[a: Type(0)](s: seq(a), i: int): a extern; 
function operator([ := ]) #[a: Type(0)](s: seq(a), i: int, v: a): seq(a) extern;
function operator([ .. ]) #[a: Type(0)](s: seq(a), begin: int, end: int): seq(a) extern;
function seq_len #[a: Type(0)] (s: seq(a)): nat extern;
function seq_concat #[a: Type(0)](x: seq(a), y: seq(a)): seq(a) extern;
function seq_append #[a: Type(0)](xs: seq(a), x: a): seq(a) extern;

type map(a: Type(0), b: Type(0)): Type(0) extern;
function operator(?[]) #[a:Type(0), b:Type(0)](m:map(a, b), rsa:a):bool extern;
function operator([]) #[a: Type(0), b: Type(0)](m: map(a, b), rsa: a): b extern;
function operator([ := ]) #[a: Type(0), b: Type(0)](m: map(a, b), rsa: a, v: b): map(a, b) extern;

type nat:     Type(0) := int_range(0, _);
type uint1:   Type(0) := int_range(0, 1);
type uint2:   Type(0) := int_range(0, 3);
type uint5:   Type(0) := int_range(0, 31);
type uint32:  Type(0) := int_range(0, 0xffffffff);
type uint64:  Type(0) := int_range(0, 0xffffffff_ffffffff);
type uint128: Type(0) := int_range(0, 0xffffffff_ffffffff_ffffffff_ffffffff);
type uint256: Type(0) := int_range(0, 0xffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff);

type int32:  Type(0) := int_range((-0x80000000), 0x7fffffff);
type int64:  Type(0) := int_range((-0x80000000_00000000), 0x7fffffff_ffffffff);
    
function power(b: int, e: nat) : int extern;
function cong(a: int, b: int, n: int) : bool extern;

const BASE_32:  nat extern;
const BASE_64:  nat extern; 
const BASE_128: nat extern; 
const BASE_256: nat extern;
const BASE_512: nat extern;
const NUM_WORDS:nat extern;
    
const BASE_31:  int extern;
const BASE_63:  int extern; 
    
function to_uint32(i:int) : uint32 extern;
function to_int32(i:uint32) : int32 extern;

function to_uint64(i:int) : uint64 extern;
function to_int64(i:uint64) : int64 extern;

type state: Type(0) {: primitive} extern;
function operator(.ok) (s: state): bool extern;
function operator(.ok :=) (s: state, b: bool): state extern;

type reg32_t: Type(0) extern;

type mem_t: Type(0) := map(int, seq(uint32));
    
function mem_base_addr_valid(wmem: mem_t, ptr: int, size: nat): bool extern;

type gprs_t: Type(0) extern;
function operator([]) (s: gprs_t, i: int): uint32 extern; 
function operator([ := ]) (s: gprs_t, i: int, v: uint32): gprs_t extern;
function operator([ .. ]) (s: gprs_t, begin: int, end: int): seq(uint32) extern;

function Loop(u: uint32) : bool extern;
function LoopImm(u: uint32) : bool extern;

function fst #[a: Type(0), b: Type(0)](m: tuple(a, b)): a extern;
function snd #[a: Type(0), b: Type(0)](m: tuple(a, b)): b extern;

function bool_to_uint1(i:bool) : uint1 extern;
function A_as_carry(i:int) : uint1 extern;

var gprs: gprs_t {:state gprs()};

var ok: bool {:state ok()};
    
var mem: mem_t {:state mem()};
function mem_addr_valid(h: mem_t, ptr: int): bool extern;

type uint64_view_t: Type(0) extern;
function uint64_cons(lh: uint32, uh: uint32, full: uint64) : uint64_view_t extern;
function valid_uint64_view(view: uint64_view_t, lh: uint32, uh: uint32) : bool extern;

type int64_view_t: Type(0) extern;
function int64_cons(lh: uint32, uh: uint32, full: int64) : int64_view_t extern;
function valid_int64_view(view: int64_view_t, lh: uint32, uh: uint32) : bool extern;
function operator(.lh) (num: int64_view_t) : uint32 extern;
function operator(.uh) (num: int64_view_t) : uint32 extern;
function operator(.full) (num: int64_view_t) : int extern;

type iter_t: Type(0) extern;
function iter_inv(iter: iter_t, h: mem_t, ptr: int): bool extern;
function iter_safe(iter: iter_t, h: mem_t, ptr: int): bool extern;
    
function iter_cons(base_addr: int, index: nat, buff: seq(uint32)): iter_t extern;
function lw_next_iter(iter: iter_t): iter_t extern;
function lw_prev_iter(iter: iter_t): iter_t extern;
function sw_next_iter(iter: iter_t, value: uint32): iter_t extern;
function operator(.base_addr) (iter :iter_t): int extern;
function operator(.index) (iter :iter_t): int extern;
function operator(.index := ) (iter: iter_t, i :int): iter_t extern;
function operator(.buff) (iter :iter_t): seq(uint32) extern;
function operator(.buff := ) (iter :iter_t, buff: seq(uint32)): iter_t extern;

function to_nat(s: seq(uint32)): nat extern;
ghost procedure to_nat_lemma_1(ghost xs: seq(uint32)) extern;
 
type string: Type(0) extern;

var x0: uint32 {:state reg32_t(GPR(0))};
var x1: uint32 {:state reg32_t(GPR(1))};
var x2: uint32 {:state reg32_t(GPR(2))};
var x3: uint32 {:state reg32_t(GPR(3))};
var x4: uint32 {:state reg32_t(GPR(4))};
var x5: uint32 {:state reg32_t(GPR(5))};
var x6: uint32 {:state reg32_t(GPR(6))};
var x7: uint32 {:state reg32_t(GPR(7))};
var x8: uint32 {:state reg32_t(GPR(8))};
var x9: uint32 {:state reg32_t(GPR(9))};
var x10: uint32 {:state reg32_t(GPR(10))};
var x11: uint32 {:state reg32_t(GPR(11))};
var x12: uint32 {:state reg32_t(GPR(12))};
var x13: uint32 {:state reg32_t(GPR(13))};
var x14: uint32 {:state reg32_t(GPR(14))};
var x15: uint32 {:state reg32_t(GPR(15))};
var x16: uint32 {:state reg32_t(GPR(16))};
var x17: uint32 {:state reg32_t(GPR(17))};
var x18: uint32 {:state reg32_t(GPR(18))};
var x19: uint32 {:state reg32_t(GPR(19))};
var x20: uint32 {:state reg32_t(GPR(20))};
var x21: uint32 {:state reg32_t(GPR(21))};
var x22: uint32 {:state reg32_t(GPR(22))};
var x23: uint32 {:state reg32_t(GPR(23))};
var x24: uint32 {:state reg32_t(GPR(24))};
var x25: uint32 {:state reg32_t(GPR(25))};
var x26: uint32 {:state reg32_t(GPR(26))};
var x27: uint32 {:state reg32_t(GPR(27))};
var x28: uint32 {:state reg32_t(GPR(28))};
var x29: uint32 {:state reg32_t(GPR(29))};
var x30: uint32 {:state reg32_t(GPR(30))};
var x31: uint32 {:state reg32_t(GPR(31))};

operand_type reg32: uint32 @ reg32_t :=
| inout x0 | inout x1 | inout x2 | inout x3
| inout x4 | inout x5 | inout x6 | inout x7
| inout x8 | inout x9 | inout x10 | inout x11
| inout x12 | inout x13 | inout x14 | inout x15
| inout x16 | inout x17 | inout x18 | inout x19
| inout x20 | inout x21 | inout x22 | inout x23
| inout x24 | inout x25 | inout x26 | inout x27
| inout x28 | inout x29 | inout x30 | inout x31;

operand_type imm128: uint128 := const;
operand_type imm32: uint32 := const;
operand_type imm2: uint2 := const;
    
// signed immediate
operand_type simm32: int32 := const;

function uint32_lt(x: uint32, y: uint32): uint32 extern;
    
function uint32_add(x: uint32, y: uint32): uint32 extern;
function uint32_sub(x: uint32, y: uint32): uint32 extern;
function uint32_xor(x: uint32, y: uint32): uint32 extern;
function uint32_or(x: uint32, y: uint32): uint32 extern;
function uint32_and(x: uint32, y: uint32): uint32 extern;
function uint32_mul(x: uint32, y: uint32): uint32 extern;
function uint32_mulhu(x: uint32, y: uint32): uint32 extern;
function uint32_not(x: uint32): uint32 extern;
function uint32_ls(x: uint32, amount: uint32): uint32 extern;
function uint32_rs(x: uint32, y: uint32): uint32 extern;
function uint32_arith_rs(x: uint32, y: uint32): uint32 extern;
function uint32_mul(x: uint32, y: uint32): uint32 extern;
function uint32_mulhu(x: uint32, y: uint32): uint32 extern;
   
function int32_rs(x: int32, shift: nat): int32 extern;
function int32_lt(x: int32, y: int32): uint32 extern;

function uint64_uh(v: uint64) : uint32 extern;
function uint64_lh(v: uint64) : uint32 extern;
function operator(.lh) (value : uint64_view_t): uint32 extern;
function operator(.uh) (value : uint64_view_t): uint32 extern;
function operator(.full) (value : uint64_view_t): uint64 extern;

// --------------------------------------------------------------
// Base Integer Instructions
// --------------------------------------------------------------
    
// load instructions
procedure lw_stack(inout dst: reg32, in src2: imm32, ghost index: nat)
    {:instruction Ins32(RV_LW(dst, GPR(2), src2))}
    reads
        x2; mem;
    requires
        src2 < 4096; // 12-bit
        4 * index == src2;
        mem?[x2];
        index < seq_len(mem[x2]);
    ensures
        // mem location = src + sign-extended immediate
        dst == old(mem[x2][index]);
{
    assume false;
}

procedure lw_iter(inout dst: reg32, in src1: reg32, in src2: imm32, ghost iter: iter_t)
    {:instruction Ins32(RV_LW(dst, src1, src2))}
    reads
        mem;
    requires
        src2 < 4096; // 12-bit
        iter_safe(iter, mem, src1 + src2);
    ensures
        // mem location = src + sign-extended immediate
        dst == old(mem[iter.base_addr][iter.index]);
{
    assume false;
}

procedure lw_next(inout dst: reg32, in src1: reg32, in src2: imm32, ghost iter: iter_t)
    returns (ghost next_iter: iter_t)
    reads
        mem;
    requires
        src2 < 4096; // 12-bit
        iter_safe(iter, mem, src1 + src2);
    ensures
        dst == old(mem[iter.base_addr][iter.index]);
        next_iter == lw_next_iter(iter);
        iter_inv(next_iter, mem, old(src1) + old(src2) + 4);
{
    next_iter := lw_next_iter(iter);
    lw_iter(dst, src1, src2, iter);
}

procedure lw_prev(inout dst: reg32, in src1: reg32, in src2: imm32, ghost iter: iter_t)
    returns (ghost prev_iter: iter_t)
    reads
        mem;
    requires
        src2 < 4096; // 12-bit
        iter_safe(iter, mem, src1 + src2);
    ensures
        dst == old(mem[iter.base_addr][iter.index]);
        prev_iter == lw_prev_iter(iter);
        old(src1) + old(src2) != iter.base_addr
            ==>
        iter_inv(prev_iter, mem, old(src1) + old(src2) - 4);
{
    prev_iter := lw_prev_iter(iter);
    lw_iter(dst, src1, src2, iter);
}

// procedure lh(inout dst: reg32, in src1: reg32, in src2: imm32)
    // {:instruction Ins32(RV_LH(dst, src1, src2))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + src2);
        // src1 < 0x10000; // 16-bit
        // src2 < 0x1000;  // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + old(src2));
        // // mem location = sign-extended src + sign-extended immediate
        // dst == mem[old(src1) + old(src2)];
// {
    // assume false;
// }
// 
// procedure lhu(inout dst: reg32, in src1: reg32, in src2: imm32)
    // {:instruction Ins32(RV_LHU(dst, src1, src2))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + src2);
        // src1 < 0x10000; // 16-bit
        // src2 < 0x1000;  // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + old(src2));
        // // mem location = zero-extended src + zero-extended immediate
        // dst == mem[old(src1) + old(src2)];
// {
    // assume false;
// }
// 
// procedure lb(inout dst: reg32, in src1: reg32, in src2: imm32)
    // {:instruction Ins32(RV_LB(dst, src1, src2))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + src2);
        // src1 < 0x100; // 8-bit
        // src2 < 0x1000;  // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + old(src2));
        // // mem location = sign-extended src + sign-extended immediate
        // dst == mem[old(src1) + old(src2)];
// {
    // assume false;
// }
// 
// procedure lbu(inout dst: reg32, in src1: reg32, in src2: imm32)
    // {:instruction Ins32(RV_LBU(dst, src1, src2))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + src2);
        // src1 < 0x100; // 8-bit
        // src2 < 0x1000;  // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + old(src2));
        // // mem location = zero-extended src + zero-extended immediate
        // dst == mem[old(src1) + old(src2)];
// {
    // assume false;
// }
// 


// immediate instructions
// all immediate instructions take a 12-bit immediate and sign extend it
    
procedure addi(inout dst: reg32, in src1: reg32, in src2: simm32)
    {:instruction Ins32(RV_ADDI(dst, src1, src2))}
    // requires
    // src1 + to_uint32(src2) < 0x1_0000_0000
    ensures
        dst == uint32_add(old(src1), to_uint32(old(src2)));
{
    assume false;
}
    
// pseudo-instruction: mv dst src is addi dst src 0
procedure mv(inout dst: reg32, in src: reg32)
    {:instruction Ins32(RV_ADDI(dst, src, 0))}
    ensures
        dst == old(src);
{
    assume false;
}

procedure slli(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SLLI(dst, src1, src2))}
    requires
        src2 < 32;
    ensures
        // left shift src1 by amount in lowest 5 bits of src2
        dst == uint32_ls(old(src1), old(src2) % 32);
{
    assume false;
}
    
// signed arguments
procedure slti(inout dst: reg32, in src1: reg32, in src2: simm32)
    {:instruction Ins32(RV_SLTI(dst, src1, src2))}
    requires
        src2 <= 2047;
    ensures
    dst == int32_lt(to_int32(old(src1)), old(src2));
{
    assume false;
}

procedure sltiu(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SLTIU(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
       dst == uint32_lt(old(src1), old(src2));
{
    assume false;
}

procedure xori(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_XORI(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == uint32_xor(old(src1), old(src2));
{
    assume false;
}

procedure ori(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_ORI(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == uint32_or(old(src1), old(src2));
{
    assume false;
}

procedure andi(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_ANDI(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == uint32_and(old(src1), old(src2));
{
    assume false;
}

    
procedure srli(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SRLI(dst, src1, src2))}
    requires
        0 <= src2 < 31;
    ensures
        dst == uint32_rs(old(src1), old(src2));
{
    assume false;
}

procedure srai(inout dst: reg32, in src1: reg32, in src2: imm32)
    {:instruction Ins32(RV_SRAI(dst, src1, src2))}
    requires
        0 <= src2 <= 31;
    ensures
        dst == to_uint32(int32_rs(to_int32(old(src1)), old(src2)));
{
    assume false;
}


// --------------------------------------------------------------
    
// store instructions
    
procedure sw_stack(in rs2: reg32, in offset: imm32, inline index: nat)
    modifies
    mem;
    reads x2;
    requires
        4 * index == offset;
        mem?[x2];
        index < seq_len(mem[x2]);
        offset < 4096;
    ensures
        mem == old(mem[x2 := mem[x2][index := rs2]]);
        {
            assume false;
        }

// TODO: double-check semantics
procedure sw(in rs2: reg32, in base: reg32, in offset: imm32, ghost iter: iter_t)
    returns (ghost next_iter: iter_t)
    {:instruction Ins32(RV_SW(rs2, base, offset))}
    modifies
        mem;
    requires
        iter_safe(iter, mem, base + offset);
        offset < 4096;
    ensures
        // store rs2 at mem[base + offset]
        mem == old(mem[iter.base_addr := mem[iter.base_addr][iter.index := rs2]]);
        iter_inv(next_iter, mem, base + offset + 4);
        next_iter == sw_next_iter(iter, rs2);
{
    assume false;
}

// procedure sh(inout src1: reg32, in src2: reg32, in offset: imm32)
    // {:instruction Ins32(RV_SH(src1, src2, offset))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + offset);
        // src2 < 0x10000; // 16-bit
        // offset < 0x1000; // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + offset);
        // // mem location = src1 + sign-extended offset, store signed src2 value at mem location
        // mem[old(src1) + offset] == old(src2);
// {
    // assume false;
// }
// 
// procedure sb(inout src1: reg32, in src2: reg32, in offset: imm32)
    // {:instruction Ins32(RV_SB(src1, src2, offset))}
    // reads
        // mem;
    // requires
        // mem_addr_valid(mem, src1 + offset);
        // src2 < 0x100; // 8-bit
        // offset < 0x1000; // 12-bit
    // ensures
        // mem_addr_valid(mem, old(src1) + offset);
        // // mem location = src1 + sign-extended offset, store signed src2 value at mem location
        // mem[old(src1) + offset] == old(src2);
// {
    // assume false;
// }
// 
// --------------------------------------------------------------

// register-register operations
    
procedure add(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_ADD(dst, src1, src2))}
    // requires
    //    src1 + src2 < 0xffff_ffff;
    ensures
        dst == uint32_add(old(src1), old(src2));
{
    assume false;
}

// add instruction where we expect/allow an overflow to occur
procedure add_wrap(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_ADD(dst, src1, src2))}
    ensures
        dst == uint32_add(old(src1), old(src2));
{
    assume false;
}

procedure sub(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SUB(dst, src1, src2))}
    // requires
    //     src1 - src2 >= 0;
    ensures
        dst == uint32_sub(old(src1), old(src2));
{
    assume false;
}

procedure sll(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SLL(dst, src1, src2))}
    ensures
        // left shift src1 by amount in lowest 5 bits of src2
        dst == uint32_ls(old(src1), old(src2) % 32);
{
    assume false;
}

procedure slt(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SLT(dst, src1, src2))}
    ensures
        // < comparison as signed ints
        dst == int32_lt(to_int32(old(src1)), to_int32(old(src2)));
{
    assume false;
}

procedure sltu(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SLTU(dst, src1, src2))}
    ensures
        // < comparison as unsigned ints
        dst == uint32_lt(old(src1), old(src2));
{
    assume false;
}

procedure xor(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_XOR(dst, src1, src2))}
    ensures
        dst == uint32_xor(old(src1), old(src2));
{
    assume false;
}

procedure srl(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SRL(dst, src1, src2))}
    requires
        // limit to non-negative values for our use case
        0 <= src2 < 31;
    ensures
        // right logical shift by lowest 5 bits of src2
        dst == uint32_rs(old(src1), old(src2));
{
    assume false;
}

procedure sra(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_SRA(dst, src1, src2))}
    requires
         0 <= src2 < 31;
    ensures
        // right arithmetic shift by lowest 5 bits of src2
        dst == uint32_rs(old(src1), old(src2));
{
    assume false;
}

procedure or(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_OR(dst, src1, src2))}
    ensures
        dst == uint32_or(old(src1), old(src2));
{
    assume false;
}

procedure and(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_AND(dst, src1, src2))}
    ensures
        dst == uint32_and(old(src1), old(src2));
{
    assume false;
}

procedure lui(inout dst: reg32, in src: imm32)
    {:instruction Ins32(RV_LUI(dst, src))}
    requires
        src < 0x100000; // 20-bit immediate
    ensures
        dst == uint32_ls(old(src), 12);
{
    assume false;
}

procedure li(inout dst: reg32, in src: imm32)
    {:instruction Ins32(RV_LI(dst, src))}
    ensures
        dst == src;
{
    assume false;
}


// --------------------------------------------------------------
// Integer Multiplication and Division Extension
// --------------------------------------------------------------

// todo: mulh mulshu div divu rem remu

procedure mul(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_MUL(dst, src1, src2))}
    ensures
        dst == uint32_mul(old(src1), old(src2));
{
    assume false;
}

procedure mulhu(inout dst: reg32, in src1: reg32, in src2: reg32)
    {:instruction Ins32(RV_MULHU(dst, src1, src2))}
    ensures
        dst == uint32_mulhu(old(src1), old(src2));
{
    assume false;
}
    
#verbatim
} // end module bignum_decls
#endverbatim
