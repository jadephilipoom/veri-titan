include{: verbatim} "../../arch/msp430/vale.i.dfy"

#verbatim
module msp_decls {

import opened integers
import opened bv16_ops
import opened msp_machine
import opened msp_vale
import opened mem
import opened stack

#endverbatim

type seq(a: Type(0)): Type(0) {: primitive} extern;
function operator([]) #[a: Type(0)](s: seq(a), i: int): a extern; 
function operator([ := ]) #[a: Type(0)](s: seq(a), i: int, v: a): seq(a) extern;
function operator([ .. ]) #[a: Type(0)](s: seq(a), begin: int, end: int): seq(a) extern;
function seq_len #[a: Type(0)] (s: seq(a)): nat extern;
function seq_concat #[a: Type(0)](x: seq(a), y: seq(a)): seq(a) extern;
function seq_append #[a: Type(0)](xs: seq(a), x: a): seq(a) extern;

type map(a: Type(0), b: Type(0)): Type(0) extern;
function operator(?[]) #[a:Type(0), b:Type(0)](m:map(a, b), rsa:a):bool extern;
function operator([]) #[a: Type(0), b: Type(0)](m: map(a, b), rsa: a): b extern;
function operator([ := ]) #[a: Type(0), b: Type(0)](m: map(a, b), rsa: a, v: b): map(a, b) extern;

function fst #[a: Type(0), b: Type(0)](m: tuple(a, b)): a extern;
function snd #[a: Type(0), b: Type(0)](m: tuple(a, b)): b extern;

type nat:     Type(0) := int_range(0, _);
type uint1:   Type(0) := int_range(0, 1);
type uint2:   Type(0) := int_range(0, 3);
type uint5:   Type(0) := int_range(0, 31);
type uint8:   Type(0) := int_range(0, 255);
type int16:   Type(0) := int_range((-32768), 32767);
type uint16:  Type(0) := int_range(0, 65535);
type uint32:  Type(0) := int_range(0, 0xffffffff);

type string: Type(0) extern;

function power(b: int, e: nat) : nat extern;
function cong(a: int, b: int, n: int) : bool extern;
function cong_B16(a: int, b: int): bool extern;

const BASE_16:  nat extern;
const BASE_32:  nat extern;
const NUM_WORDS:nat extern;
    
const NA: int extern;

type state: Type(0) {: primitive} extern;
function operator(.ms) (s: state): state extern; // small hack
function operator(.ok) (s: state): bool extern;
function operator(.ok :=) (s: state, b: bool): state extern;

type reg_t: Type(0) extern;

type operand_t: Type(0) extern;
function Reg(r: reg_t): operand_t extern;
function Idx(r: reg_t, index: uint16): operand_t extern;
function RegIndir(r: reg_t, inc: bool): operand_t extern;
function Imm(i: uint16): operand_t extern;

function mem_base_ptr_valid(wmem: mem_t, ptr: int, size: nat): bool extern;

function bool_to_uint1(i:bool) : uint1 extern;
function A_as_carry(i:int) : uint1 extern;

var ok: bool {:state ok()};

type flat_t: Type(0) extern;
var flat: flat_t {:state flat()};

type heap_t:  Type(0) := map(int, entry_t);
var heap: heap_t {:state heap()};
function heap_b16_write(heap: heap_t, iter: iter_t, value: uint16): heap_t extern;

type entry_t: Type(0) extern;
function B16(b: seq(uint16)): entry_t extern;
function operator(.b16) (e :entry_t): seq(uint16) extern;

type frames_t: Type(0) extern;
var frames: frames_t {:state frames()};
function operator(.fs) (m: frames_t): seq(frame_t) extern;
function operator(.sp) (m: frames_t): int extern;

type frame_t: Type(0) extern;
function operator(.fp) (f: frame_t): uint16 extern;
function operator(.content) (f: frame_t): seq(uint16) extern;

type mem_t: Type(0) extern;
var mem: mem_t {:state mem()};
function operator(.frames) (m: mem_t): frames_t extern;
function operator(.heap) (m: mem_t): heap_t extern;
function read_top_frame(fs: mem_t): seq(uint16) extern;

function in_stack_addr_range(addr: int): bool extern;

type iter_t: Type(0) extern;
function iter_inv(iter: iter_t, h: heap_t, ptr: int): bool extern;
function iter_safe(iter: iter_t, h: heap_t, ptr: int): bool extern;

function iter_cons(base_ptr: int, index: nat, buff: seq(uint16)): iter_t extern;
function b16_iter_load_next(iter: iter_t, inc: bool): iter_t extern;
function b16_iter_load_prev(iter: iter_t): iter_t extern;
function b16_iter_store_next(iter: iter_t, value: uint16, inc: bool): iter_t extern;
function operator(.base_ptr) (iter :iter_t): int extern;
function operator(.index) (iter :iter_t): int extern;
function operator(.index := ) (iter: iter_t, i :int): iter_t extern;
function operator(.buff) (iter :iter_t): seq(uint16) extern;
function operator(.buff := ) (iter :iter_t, buff: seq(uint16)): iter_t extern;

type flags_t: Type(0) extern;
var flags: flags_t {:state flags()};

function to_nat(s: seq(uint16)): nat extern;

type rsa_params: Type(0) extern;
function operator(.E0) (rsa: rsa_params): nat extern;
function operator(.E) (rsa: rsa_params): nat extern;
function operator(.M) (rsa: rsa_params): nat extern;
function operator(.SIG) (rsa: rsa_params): nat extern;
function operator(.M0D) (rsa: rsa_params): uint16 extern;
function operator(.B256_INV) (rsa: rsa_params): nat extern;
function operator(.R) (rsa: rsa_params): nat extern;
function operator(.RR) (rsa: rsa_params): nat extern;
function operator(.R_INV) (rsa: rsa_params): nat extern;
function rsa_params_inv(rsa: rsa_params): bool extern;

var sp: uint16 {:state reg_t(SP)};
var r3: uint16 {:state reg_t(R(3))};
var r4: uint16 {:state reg_t(R(4))};
var r5: uint16 {:state reg_t(R(5))};
var r6: uint16 {:state reg_t(R(6))};
var r7: uint16 {:state reg_t(R(7))};
var r8: uint16 {:state reg_t(R(8))};
var r9: uint16 {:state reg_t(R(9))};
var r10: uint16 {:state reg_t(R(10))};
var r11: uint16 {:state reg_t(R(11))};
var r12: uint16 {:state reg_t(R(12))};
var r13: uint16 {:state reg_t(R(13))};
var r14: uint16 {:state reg_t(R(14))};
var r15: uint16 {:state reg_t(R(15))};


operand_type reg: uint16 @ reg_t :=
    | inout r3  | inout r4  | inout r5  | inout r6
    | inout r7  | inout r8  | inout r9  | inout r10
    | inout r11 | inout r12 | inout r13 | inout r14
    | inout r15;

function mod(a: int, n: nat): int extern;

function stack_push_frame(mem: mem_t, flat: flat_t, num_bytes: int): mem_t extern;

function stack_push_batch(mem: mem_t, flat: flat_t, content: seq(uint16)): mem_t extern;

function top_frame(frames: frames_t): frame_t extern;

function write_frame(mem: mem_t, flat: flat_t, index: nat, value: uint16): tuple(mem_t, flat_t) extern;

function read_frame(mem: mem_t, flat: flat_t, index: nat): uint16 extern;

function frame_index_valid(mem: mem_t, index: nat): bool extern;

function stack_pop_frame(mem: mem_t, flat: flat_t): (new_mem: mem_t) extern;

function stack_depth(mem: mem_t): nat extern;

function STACK_START(): nat extern;

function valid_pushm_w(rs: reg_t, n: uint8): bool extern;
function pushm_w_seq(state: state, r: reg_t, n: uint8): seq(uint16) extern;

procedure pushm_w(inline n: uint8, in rs: reg)
    {:instruction Ins(MSP_PUSHM_W(Reg(rs), Imm(n)))}
    requires
        in_stack_addr_range(sp - 2 * n);
        valid_pushm_w(@rs, n);
    
    modifies
        mem; flat; sp;

    ensures
        mem == stack_push_batch(old(mem), old(flat),
            pushm_w_seq(old(this.ms), @rs, n));
        sp == old(sp) - 2 * n;
{
    assume false;
}

function R(index: int): reg_t extern;

procedure save_r10__r7()
    requires
        in_stack_addr_range(sp - 8);
    
    modifies
        mem; flat; sp;
    reads
        r10; r9; r8; r7;

    ensures
        mem == stack_push_batch(old(mem), old(flat),
            seq(r10, r9, r8, r7));
        sp == old(sp) - 8;
{
    pushm_w(4, r10);
    assert pushm_w_seq(old(this.ms), R(10), 4) == seq(r10, r9, r8, r7);
}

procedure mov_w(in rs: reg, inout rd: reg)
    {:instruction Ins(MSP_MOV_W(Reg(rs), Reg(rd)))}
    ensures
        rd == old(rs);
{
    assume false;
}

procedure mov_w_imm(inline i: uint8, inout rd: reg)
    {:instruction Ins(MSP_MOV_W(Imm(i), Reg(rd)))}
    ensures
        rd == i;
{
    assume false;
}

function to_uint16(x: int16): uint16 extern;

function msp_add(x: uint16, y: uint16): tuple(uint16, flags_t) extern;

procedure add_w(in rs: reg, inout rd: reg)
    {:instruction Ins(MSP_ADD_W(Reg(rs), Reg(rd)))}
    modifies
        flags;
    ensures 
        let rst := msp_add(old(rs), old(rd));
        rd == fst(rst);
        flags == snd(rst);
{
    assume false;
}
    
procedure add_w_imm(inline imm: int16, inout rd: reg)
    {:instruction Ins(MSP_ADD_W(Imm(imm), Reg(rd)))}
    modifies
        flags;
    ensures
        let rst := msp_add(to_uint16(imm), old(rd));
        rd == fst(rst);
        flags == snd(rst);
{
    assume false;
}

procedure add_w_imm_test()
    requires r10 > 2;
    modifies r10; flags;
    ensures r10 == old(r10) - 3;
{
    add_w_imm((-3), r10);
}


#verbatim
} // end module bignum_decls
#endverbatim
