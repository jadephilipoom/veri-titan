include "../../../arch/msp430/decls.i.vad"

#verbatim

include "../../../arch/msp430/decls.i.dfy"
include "../../../../lib/bv16_mm_lemmas.i.dfy"
include "../../../../lib/falcon/mq_polys.dfy"
include "../../../../lib/falcon/msp430/mq_arith_lemmas.dfy"

module mul {

import opened msp_machine
import opened msp_decls
import opened msp_vale
import opened mem
import opened stack
import opened bv16_mm_lemmas
import opened bv16_ops
import opened integers
import opened mq_polys
import opened mq_arith_lemmas

#endverbatim

function mqsub(a: nat, b: nat): uint32 extern;
function mqadd(a: nat, b: nat): uint32 extern;

function lemma_mq_add_correct(sum: uint16, mask: uint16, r: uint16, x: uint16, y: uint16) : void extern;
function lemma_mq_sub_correct(diff: uint16, flags: flags_t, mask: uint16, r: uint16, x: uint16, y: uint16) : void extern;



procedure mq_add() 
    lets 
      Q    @= r9;
      negQ @= r10;
      x    @= r11;
      y    @= r12;
      r    @= r13;
      tmp @= r14;
    
    requires
      Q == 12289;
      negQ == 0xcfff;
      x < 12289;
      y < 12289;
    
    reads
      Q; negQ; x; y;

    modifies
      flags; r; tmp;
    
    ensures
      r == mqadd(old(x), old(y));
{
    mov_w(y, tmp);    // tmp <- y
    add_w(negQ, tmp); // tmp <- y - Q
    add_w(x, tmp);    // tmp <- y - Q + x
    let sum := tmp;

    // If we're still negative, create a mask of 0xFFFF.  Else, use 0.
    mov_w(tmp, r);     // r <- tmp
    rla_w(r);          // carry <- MSB of r
    let carry := flags.cf;
    clr_w(r);          // r <- 0
    subc_w(r, r);      // r <- 0 - carry;  r == if carry then 0xFFFF else 0
    let mask := r;

    and_w(Q, r);       // r <- Q & mask
    add_w(tmp, r);     // r <- (Q & mask) + y - Q + x

    lemma_mq_add_correct(sum, mask, r, x, y);
}


procedure mq_sub() 
    lets 
      Q    @= r9;
      x    @= r11;
      y    @= r12;
      r    @= r13;
      tmp @= r14;
    
    requires
      Q == 12289;
      x < 12289;
      y < 12289;

    reads
      Q; x; y;

    modifies
      flags; r; tmp;
    
    ensures
      r == mqsub(old(x), old(y));
{
    mov_w_imm(0-1, r); // r <- 0xFFFF

    mov_w(x, tmp);    // tmp <- x
    sub_w(y, tmp);    // tmp <- x - y
    let diff := tmp;
    let diff_flags := flags;
    
    let carry := flags.cf;  // carry == 1 if we went negative, else carry == 0

    // If we went negative, create a mask of 0xFFFF.  Else, use 0.
    clr_w(r);          // r <- 0
    subc_w(r, r);      // r <- 0 - carry;  r == if carry then 0xFFFF else 0
    let mask := r;
    
    and_w(Q, r);       // r <- Q & mask
    add_w(tmp, r);     // r <- (Q & mask) + x - y 

    lemma_mq_sub_correct(diff, flags, mask, r, x, y);
}



#verbatim
}
#endverbatim
