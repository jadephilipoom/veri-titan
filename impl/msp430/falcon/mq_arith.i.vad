include "../../../arch/msp430/decls.i.vad"

#verbatim

include "../../../arch/msp430/decls.i.dfy"
include "../../../../lib/bv16_mm_lemmas.i.dfy"

module mul {

import opened msp_machine
import opened msp_decls
import opened msp_vale
import opened mem
import opened stack
import opened bv16_mm_lemmas
import opened bv16_ops
import opened integers

#endverbatim



function mul_add_lemma(xs: seq(uint16), ys: seq(uint16),
    carry: nat, a: uint16, b: uint16): uint32_view_t extern;

procedure mq_add() 
    lets 
      Q    @= r9;
      negQ @= r10;
      x    @= r11;
      y    @= r12;
      r    @= r13;
      tmp @= r14;
    
    requires
      Q == 12289;
      negQ == 0xcfff;
      x < 12289;
      y < 12289;

    modifies
      flags; r; tmp;
    
    ensures
      r == mqadd(old(x), old(y));
{
    assert to_int32(negQ) == (-Q);

    mov_w(y, tmp);    // tmp <- y
    add_w(negQ, tmp); // tmp <- y - Q
    add_w(x, tmp);    // tmp <- y - Q + x

    // If we're still negative, create a mask of 0xFFFF.  Else, use 0.
    mov_w(tmp, r);     // r <- tmp
    rla_w(r);          // carry <- MSB of r
    let carry := flags.cf;
    clr(r);            // r <- 0
    subc(r, r);        // r <- 0 - carry;  r == if carry then 0xFFFF else 0

    and_w(Q, r);       // r <- Q & mask
    add_w(tmp, r);     // r <- (Q & mask) + y - Q + x
}


procedure mq_sub() 
    lets 
      Q    @= r9;
      x    @= r11;
      y    @= r12;
      r    @= r13;
      tmp @= r14;
    
    requires
      Q == 12289;
      x < 12289;
      y < 12289;

    modifies
      flags; r; tmp;
    
    ensures
      r == mqsub(old(x), old(y));
{
    assert to_int32(negQ) == (-Q);
    
    clr(r);               // r <- 0
    add_w_imm(0xFFFF, r); // r <- 0xFFFF

    mov_w(x, tmp);    // tmp <- x
    sub_w(tmp, y);    // tmp <- x - y
    
    let carry := flags.cf;  // carry == 0 if we went negative, else carry == 1

    // If we went negative, create a mask of 0xFFFF.  Else, use 0.
    adc_w(r);         // r <- 0xFFFF + carry;  r == if carry then 0 else 0xFFFF
    
    and_w(Q, r);       // r <- Q & mask
    add_w(tmp, r);     // r <- (Q & mask) + x - y 
}



#verbatim
}
#endverbatim
