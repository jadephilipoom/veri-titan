include "../../arch/riscv/decls.i.vad"

#verbatim
include "../../arch/riscv/decls.i.dfy"
include "../../../impl/riscv/mul32_lemmas.i.dfy"

module mul32 {

import opened bv_ops
import opened rsa_ops

import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened mul32_lemmas

#endverbatim

ghost procedure lemma_uint64_half_split(ghost x: nat) extern;

function mula32_correct_lemma(
    a: uint32, // a0
    b: uint32, // a1
    c: uint32, // a2
    a0: uint32,
    a1: uint32,
    a5: uint32
) : (uint64_view_t) extern;

function mulaa32_correct_lemma(
       a: uint32, // a0
       b: uint32, // a1
       c: uint32, // a2
       d: uint32, // a3
       a0: uint32,
       a1: uint32,
       a5: uint32
) : (uint64_view_t) extern;


procedure mul32()
    modifies
        a0; a1; a5;
    ensures
        to_nat(seq(a0, a1)) == old(a1) * old(a0);
{
    ghost var a := a0;
    ghost var b := a1;
    ghost var r := a * b;

    // move starting a1 into a5
    mv(a5, a1);

    // put upper-half of multiplication of a1 and a0 into a1
    mulhu(a1, a0, a5);
    assert a1 == uint32_mulhu(a, b);

    // put lower-half of a1 and a0 into a0
    mul(a0, a0, a5);
    assert a0 == uint32_mul(a, b);

    // end result: a0 * a1 in a1-a0, a5 has old(a1)
    lemma_uint64_half_split(r);
    to_nat_lemma_1(seq(a0, a1));
}
  
procedure mula32() returns (ghost A: uint64_view_t)
    reads
        a2;
    modifies
        a0; a1; a5;
    ensures
        valid_uint64_view(A, a0, a1);
        A.full == old(a0) * old(a1) + old(a2);
{
    ghost var a := a0;
    ghost var b := a1;
    ghost var c := a2;
    ghost var r := a * b;
    ghost var s := r + c;
   
    // bottom half of a0 * a1 in a5 
    mul(a5, a0, a1);
    assert a5 = uint32_mul(a, b);
    
    // top half of a0 * a1 in a1
    mulhu(a1, a0, a1);
    assert a1 == uint32_mulhu(a, b);

    // bottom half + a2 value in a0
    add_wrap(a0, a5, a2);
    assert a0 == uint32_add(uint32_mul(a, b), c);

    // if a0 now less than a5 it's because we overflowed
    // so we need to add 1 to a1
    sltu(a5, a0, a5);
    assert a5 == uint32_lt(a0, uint32_mul(a, b));
    
    // add 1 to top half if needed
    add_wrap(a1, a1, a5);
    assert a1 == uint32_add(uint32_mulhu(a, b), a5);
    
    // result: a0 * a1 + a2
    A := mula32_correct_lemma(a, b, c, a0, a1, a5);
}
    
procedure mulaa32() returns (ghost A: uint64_view_t)
    modifies
        a0; a1; a2; a3; a4; a5;
    ensures
        // a * b + c + d
        // a0 * a1 + (a2 + a3)
        valid_uint64_view(A, a0, a1);
        A.full == old(a0) * old(a1) + old(a2) + old(a3);
{
    ghost var a := a0;
    ghost var b := a1;
    ghost var c := a2;
    ghost var d := a3;

    ghost var r := a * b;
    ghost var s := c + d;

    ghost var t := r + s;
    
    // don't care about starting a4
    // bottom half of a0 * a1 in a4'
    mul(a4, a0, a1);
    assert a4 == uint32_mul(a, b);

    // a2 + a3 in a3'
    add_wrap(a3, a3, a2);
    assert a3 == uint32_add(c, d);

    // if a3' < a2, then addition overflowed
    // if we overflowed, a2' is 1
    sltu(a2, a3, a2);
    assert a2 == uint32_lt(uint32_add(c, d), c);

    // top half of a0 * a1 in a5'
    mulhu(a5, a0, a1);
    assert a5 == uint32_mulhu(a, b);

    // a0' == add (a3 + a2) to bottom half of (a0 * a1)
    add_wrap(a0, a4, a3);
    assert a0 == uint32_add(uint32_mul(a, b), uint32_add(c, d));

    // if a0' < a4' then addition overflowed bottom mul
    // if overflowed, a1' == 1
    sltu(a1, a0, a4);
    assert a1 == uint32_lt(uint32_add(uint32_mul(a, b), uint32_add(c, d)), uint32_mul(a, b));

    // add top half of mul and first overflow result
    add_wrap(a5, a5, a2);
    assert a5 == uint32_add(uint32_mulhu(a, b), uint32_lt(uint32_add(c, d), c));

    // add top half and second overflow result
    add_wrap(a1, a1, a5);
    assert a1 == uint32_add(uint32_lt(uint32_add(uint32_mul(a, b), uint32_add(c, d)), uint32_mul(a, b)), a5);
    
    A := mulaa32_correct_lemma(a, b, c, d, a0, a1, a5);
}

#verbatim
}
#endverbatim
