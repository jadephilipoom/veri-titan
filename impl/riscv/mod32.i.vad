include "../../arch/riscv/decls.i.vad"

#verbatim
include "../../arch/riscv/decls.i.dfy"
include "../../../impl/riscv/mod32_lemmas.i.dfy"
include "../../../impl/riscv/ge_mod.i.dfy"

module mul256 {

import opened bv_ops
import opened rsa_ops

import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened mod32_lemmas
import opened mod32_nl_lemmas

import opened BASE_32_Seq

#endverbatim
    
// ghost procedure refine_int64_view(ghost lh: uint32, ghost uh: uint32, ghost full: int64) 
// returns (ghost ref: int64_view_t)
ghost procedure trivial() returns (ghost ref: int64_view_t) extern;

ghost procedure lemma_uint64_half_split(ghost x: nat) extern;
ghost procedure sub_mod32_correct_lemma(
       ghost a: uint32,
       ghost b: uint32,
       ghost c: uint32,
       ghost x10: uint32,
       ghost x11: uint32,
       ghost x15: uint32
) extern;

function sub_mod32_loop_inv(
    iter_a: iter_t,
    iter_n: iter_t,
    iter_a': iter_t,
    A: int64_view_t): bool extern;

function seq_subb(xs: seq(uint32), ys: seq(uint32)) : tuple(seq(uint32), uint1) extern;

function lemma_sub_mod32_correct(
    A: int64_view_t,
    iter_a: iter_t,
    iter_n: iter_t,
    iter_a': iter_t,
    iter_a_next: iter_t,
    iter_n_next: iter_t,
    iter_a'_next: iter_t,
    v0: uint32,
    v1: uint32,
    lh: uint32,
    uh: uint32,
    carry_add: int,
    carry_sub: int,
    x13: uint32,
    i: int) : int64_view_t extern;

ghost procedure lemma_ge_mod32_correct(
      ghost iter_a: iter_t,
      ghost iter_n: iter_t,
      ghost iter_a_prev: iter_t,
      ghost iter_n_prev: iter_t,
      ghost cond: uint32,
      ghost b: uint32,
      ghost i: int
) extern;

// procedure loop_reg(inout src1:reg32, in src2:reg32, inline count: nat)
//     requires src2 == src1 + 4 * count;
// {
//     ghost var i: int := 0;
//     ghost var saved := src1;

//     while (src1 != src2)
//         invariant src1 <= src2;
//         invariant src1 == saved + i * 4;
//         decreases loop_ctr;
//     {
//         addi(src1, src1, 4);
//         i := i + 1;
//     }
// }

ghost sub_mod32_post_lemma(
    ghost iter_a: iter_t,
    ghost iter_n: iter_t,
    ghost iter_a': iter_t,
    ghost A: int64_view_t) extern;

procedure sub_mod32(ghost iter_n: iter_t, ghost iter_a: iter_t)
    returns (ghost iter_a': iter_t)
    requires
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 384;
        iter_n.index == 0; 

        iter_safe(iter_a, mem, x10);
        seq_len(iter_a.buff) == 384;
        iter_a.index == 0;

        iter_n.base_addr != iter_a.base_addr;
    modifies
        x10; x11; x12; x13; x14; x15; x16; mem;
    ensures
        iter_inv(iter_a', mem, x10);
        mem == old(mem)[iter_a.base_addr := iter_a'.buff];
{
    // load address of n
    lui(x12, 0x11); // 0x11000 into x12
    assume 0x11000 == x12;

    addi(x12, x12, 1560); // 71192 in x12
    assert x12 == 71192;

    addi(x16 ,x12, 384);  // 71576 in x16
    assert x16 == 71576;

    // set A to 0
    li(x15, 0); // 0 in x15 -- lower half of A
    li(x11, 0); // 0 in x11 -- upper half of A

    ghost var A: int64_view_t;
    A := trivial();

    iter_a' := iter_a;
    ghost var iter_a := iter_a;
    ghost var iter_n := iter_n;
    
    assert sub_mod32_loop_inv(iter_a, iter_n, iter_a', A) by {
        reveal SeqSub;
    }

    ghost var i: int := 0;
    ghost var n_ptr := iter_n.base_addr;
    ghost var a_ptr := iter_a.base_addr;

    while (x12 != x16)
        invariant x12 <= x16;
        invariant x12 == 71192 + 4 * i;
        invariant x16 == 71576;
        invariant 0 <= i <= 384;

        invariant iter_inv(iter_n, mem, x12);
        invariant iter_n.base_addr == n_ptr;
        invariant iter_n.index == i;
        invariant mem == old(mem)[a_ptr := iter_a'.buff];

        invariant iter_inv(iter_a', mem, x10);
        invariant seq_len(iter_a'.buff) == 384;
        invariant iter_a'.base_addr == a_ptr;
        invariant iter_a'.index == i;

        invariant iter_a.index == i;

        invariant a_ptr != n_ptr;

        invariant valid_int64_view(A, x15, x11);
        invariant sub_mod32_loop_inv(iter_a, iter_n, iter_a', A);

        decreases loop_ctr;
    {
        lw(x14, x10, 0, iter_a');
        assume x14 == iter_a.buff[i] ;

        let iter_a_next := lw_next_iter(iter_a);
        // load mem from x10 to x14 (x14 == a[i])

        let iter_n_next := lw_safe(x13, x12, 0, iter_n); 
        // load mem from x12 into x13 (x13 == n[i])
        addi(x12, x12, 4); // increment n pointer

        ghost var a_i := iter_a.buff[i];
        ghost var n_i := iter_n.buff[i];

        add(x15, x15, x14); // lower half of A += a[i]
        // assert x15 == uint32_add(A.lh, a_i);
        ghost var v0 := uint32_add(A.lh, a_i);

        sub(x13, x15, x13); // lower half of A -= n[i]
        // assert x13 == uint32_sub(uint32_add(A.lh, a_i), n_i);

        sltu(x14, x15, x14); // overflow check from add
        let carry_add := x14;
        // assert carry_add == uint32_lt(uint32_add(A.lh, a_i), a_i);

        add(x14, x14, x11); // add carry bit to upper half of A

        ghost var v1 := x14;
        // assert v1 == uint32_add(A.uh, carry_add);

        sltu(x15, x15, x13); // underflow check from sub
        
        let carry_sub := x15;

        let iter_a'_next := sw(x13, x10, 0, iter_a');

        addi(x10, x10, 4); // increment a pointer
        sub(x15, x14, x15); // subtract underflow carry from upper half of A
        srai(x11, x15, 0x1f); 

        // assert x11 == to_uint32(int32_rs(to_int32(v2), 31));

        A := lemma_sub_mod32_correct(A, iter_a, iter_n, iter_a',
            iter_a_next, iter_n_next, iter_a'_next,
            v0, v1, x15, x11, carry_add, carry_sub, x13, i);

        iter_n := iter_n_next;
        iter_a' := iter_a'_next;
        iter_a := iter_a_next;
        i := i + 1;
    }

    sub_mod32_post_lemma(iter_a, iter_n, iter_a', A);
}
    
    
// procedure ge_mod32(ghost iter_n: iter_t, ghost iter_a: iter_t)
//     returns (ghost result: bool)
//     requires
//         iter_safe(iter_n, mem, 71192);
//         seq_len(iter_n.buff) == 384;
// 
//         iter_safe(iter_a, mem, x10);
//         seq_len(iter_a.buff) == 384;
//     
//         // TODO: should be hard-coded in the semantics
//         x0 == 0;
//     reads
//         x0; mem;
//     modifies
//         x10; x11; x12; x13; x14; x15;
//     ensures
//         // iter valid for n
//         iter_safe(iter_n, mem, 71192);
//         seq_len(iter_n.buff) == 384 ;
// 
//         // iter valid for a
//         iter_safe(iter_a, mem, 71192);
//         seq_len(iter_a.buff) == 384 ;
//     
//         result == to_nat(iter_a.buff) >= to_nat(iter_n.buff);
//   {
// 
//     lui(x11, 0x11); // 0x11000 into x11
//     addi(x15, x11, 1560); // n = 71192 into x15
// 
//     addi(x10, x10, 380); // pointer to end of a
//     addi(x15, x15, 380); // pointer to end of n
//     addi(x11, x11, 1560); // pointer to beginning of n
//     
//     addi(x12, x0, 1); // move 1 into x12 -- x12 = cond
// 
//     ghost var iter_a := iter_a;
//     ghost var iter_n := iter_n;
//     while (x12 != x0)
//     invariant iter_inv(iter_a, mem, x10);
//     invariant iter_inv(iter_n, mem, x15);
//     invariant iter_a.index == iter_n.index;
//     invariant iter_a.index > 0;
//     decreases x12;
//     {
//       
//       let iter_a_prev := lw_prev(x13, x10, 0, iter_a); // x13 = a[i] -- 10148
//       let iter_n_prev := lw_prev(x14, x15, 0, iter_n); // x14 = n[i]
//       
//       addi(x15, x15, (-4)); // x15 = pointer to n[i-1]
//       addi(x10, x10, (-4)); // x10 = pointer to a[i-1]
// 
//       // if a[i] != n[i]
//       sub(x12, x13, x14); // a[i] - n[i]
//       sltu(x12, x0, x12); // 0 if a[i] - n[i] = 0, else 1
// 
//       slt(x13, x0, x12); // 0 if 0 < a[i] - n[i]
// 
//       xor(x12, x11, x15);
//       sltu(x12, x0, x12); // 1 if 0 < x12, 0 if they're equal 
//     
//       iter_a := iter_a_prev;
//       iter_n := iter_n_prev;
//     
//       // x12 = cond, x13 = b
//       //lemma_ge_mod32_correct(iter_a, iter_n, iter_a_prev, iter_n_prev, x12, x13, iter_a.index);
//     }
//     
//     // move b value to expected result register
//     mv(x10, x13);
//   }

#verbatim
}
#endverbatim
