include "../../arch/riscv/decls.i.vad"
include "mul32.i.vad"

#verbatim
include "../../arch/riscv/decls.i.dfy"
include "../../impl/riscv/mul32.i.dfy"

module mont_mul_add {

import opened bv_ops
// import opened rsa_ops

import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened mul32

#endverbatim

// /**
//  * Montgomery c[] += a * b[] / R % mod
//  */
// static void mont_mul_add(const uint32_t d0inv, const uint32_t *n,
//        uint32_t *c,
//        const uint32_t a,
//        const uint32_t *b)
// {
//   uint64_t A = mula32(a, b[0], c[0]);
//   uint32_t d0 = (uint32_t)A * d0inv;
//   uint64_t B = mula32(d0, n[0], (uint32_t)A);
//   uint32_t i;
//   for (i = 1; i < RSANUMWORDS; ++i) {
//     A = mulaa32(a, b[i], c[i], A >> 32);
//     B = mulaa32(d0, n[i], (uint32_t)A, B >> 32);
//     c[i - 1] = (uint32_t)B;
//   }
//   A = (A >> 32) + (B >> 32);
//   c[i - 1] = (uint32_t)A;
//   if (A >> 32)
//     sub_mod(n, c);
// }
    
procedure mont_mul_add(ghost d0inv: uint32, ghost iter_stack: iter_t, ghost iter_a: iter_t, ghost iter_b: iter_t, ghost iter_c: iter_t, ghost iter_n: iter_t)
    returns (ghost iter_c' : iter_t)
    lets sp @= x2; // stack pointer
         s0 @= x16; s1 @= x17;
         s2 @= x18; s3 @= x19; s4 @= x20; s5 @= x21; s6 @= x22;
         s7 @= x23; s8 @= x24; // saved registers
         a0 @= x10; a1 @= x11; a2 @= x12; a3 @= x13; // fn args and return values
         ra @= x1; //return addr
    requires sp > 48;
    requires iter_safe(iter_stack, mem, sp-48);
    requires seq_len(iter_stack.buff) == 12;
    requires iter_stack.index == 0;

    modifies sp; s0; s1; s2; s3; s4; s5; s6; s7; s8; a0; a1; a2; a3;
             x14; x15;
             ra; mem;
    // ensures
  {
    
    ghost var iter_n := iter_n;
    ghost var iter_a := iter_a;
    ghost var iter_b := iter_b;
    ghost var iter_c := iter_c;
    
    // starting values
    // a0 = d0inv
    // a1 = pointer to c
    // a2 = a
    // a3 = pointer to b

    // sp to start of stack
    addi(sp, sp, (-48));

    // store s6 to sp[4]
    sw_stack(s6, 16, 4);

    // s6 <- a1
    mv(s6, a1);

    // store store s7 sp[3]
    sw_stack(s7, 12, 3);

    // a1 <- a3 = b[0]
    lw_iter(a1, a3, 0, iter_b);

    //s7 <- a2 = "a"
    mv(s7, a2);

    // a2 <- original a1 = c[0]
    lw_iter(a2, s6, 0, iter_c);

    // store s5 to sp+20
    sw_stack(s5, 20, 5);

    // s5 <- a0 = d0inv
    mv(s5, a0);

    // a0 <- original a2 == "a"
    mv(a0, s7);

    sw_stack(ra, 44, 11);
    sw_stack(s0, 40, 10);
    sw_stack(s1, 36, 9);
    sw_stack(s2, 32, 8);
    sw_stack(s3, 28, 7);
    sw_stack(s4, 24, 6);
    sw_stack(s8, 8, 2);

    // s4 <- pointer to b
    mv(s4, a3);
    
    // ** before mula32 call:
    //      sp[2..10] = s8, s7, ..., s10
    //      sp[11] = ra

    //      a0 = a, a1 = b[0], a2 = c[0]
    //      s6 = pointer to (beginning of) c
    //      s5 = d0inv
    //      s4 = pointer to b
    //      s7 = a

    // a0(lh), a1(uh) = A == a * b[0] + c[0]
    mula32();

    // s5 <- A(lh) * d0inv
    mul(s5, a0, s5);

    // s8 <- pointer to n (71192)
    lui(s8, 0x11);
    addi(s8, s8, 1560);

    // s0 <- A(uh)
    mv(s0, a1);
    // a1 <- n[0]
    lw_iter(a1, s8, 0, iter_n);
    // a2 <- A(lh)
    mv(a2, a0);

    // s2 <- pointer to n[1]
    addi(s2, s8, 4);
    // s4 <- pointer to b[1]
    addi(s4, s4, 4);

    // s3 <- pointer to c
    mv(s3, s6);

    // s8 <- pointer to end of n
    addi(s8, s8, 384);
    
    // a0 = d0
    mv(a0, s5);
    
    // a0(lh), a1(uh) = B == d0 * n[0] + A(lh)
    mula32();

    // s1 <- B(uh)
    mv(s1, a1);

    // a2 <- c[1]
    lw_iter(a2, s3, 4, iter_c);
    
    // a1 <- b[1]
    lw_iter(a1, s4, 0, iter_b);

    // a3 <- A(uh)
    mv(a3, s0);

    // a0 <- a
    mv(a0, s7);

    // registers going into loop:
    // a0 = a, a1 = b[1], a2 = c[1], a3 = A(uh)
    // s0 = A(uh)
    // s1 = B(uh)
    // s2 = pointer to n[1]
    // s3 = pointer to c[0]
    // s4 = pointer to b[1]
    // s5 = d0;
    // s8 = pointer to end of n

    // a0(lh), a1(uh) = A == a * b[i] + c[i] + A(uh)
    mulaa32();

    // s0 <- A(uh)
    mv(s0, a1);

    // a1 <- n[i]
    lw_iter(a1, s2, 0, iter_n);

    // a2 <- A(lh)
    mv(a2, a0);

    // a3 <- B(uh)
    mv(a3, s1);

    // a0 <- d0
    mv(a0, s5);

    // a0(lh), a1(uh) = B == d0 * n[i] + A(lh) + B(uh)
    mulaa32();

    // c[i-1] <- B(lh) -- store to c
    sw(a0, s3, 0, iter_c);

    // s2 <- n[i+1] -- increment pointer to n
    addi(s2, s2, 4);
    
    // s1 <- B(uh)
    mv(s1, a1);
    
    // s4 <- b[i+1] -- increment pointer to b
    addi(s4, s4, 4);
    // s3 <- c[i] -- increment pointer to c
    addi(s3, s3, 4);

    // loop if s8 != s2 (if n[i+1] not at end of n)
    // bne    s8, s2, mont_mul_add.constprop.0+0x4c> <-- mulaa32();

    // end of loop:
    // c[0..i-1] computed

    // s1 = B(uh)
    // s2 = end of n
    // s3 = last spot of c
    // s4 = end of b

    // s0 <- lower half of A(uh) + B(uh) == A'
    add(s0, s0, a1);

    // c[i] <- s0 -- store to last spot of c
    sw(s0, s6, 380, iter_c);

    // true when A(uh) > 0, causing lh(A(uh + B(uh) to overflow
    // lh(A(uh + B(uh)) < B(uh) <-- happens when A'(uh) is non-empty
    // TODO: if/else?
    // bltu    s0, a1, 1026a <mont_mul_add.constprop.0+0x9a>

    // A'(lh) <= 0 case:
    // recover stack
    lw_stack(ra, 44, 11);
    lw_stack(s0, 40, 10);
    lw_stack(s1, 36, 9);
    lw_stack(s2, 32, 8);
    lw_stack(s3, 28, 7);
    lw_stack(s4, 24, 6);
    lw_stack(s5, 20, 5);
    lw_stack(s6, 16, 4);
    lw_stack(s7, 12, 3);
    lw_stack(s8, 8, 2);

    // recover initial sp
    addi(sp, sp, 48);
    // ret
   
    // A'(lh) > case:
    lw_stack(s0, 40, 10);
    lw_stack(ra, 44, 11);
    lw_stack(s1, 36, 9);
    lw_stack(s2, 32, 8);
    lw_stack(s3, 28, 7);
    lw_stack(s4, 24, 6);
    lw_stack(s5, 20, 5);
    lw_stack(s7, 12, 3);
    lw_stack(s8, 8, 2);
    
    // a0 <- pointer to start of c
    mv(a0, s6);

    lw_stack(s6, 16, 4);

    // recover initial sp
    addi(sp, sp, 48);

    // a0 = sub_mod(n, c) == 1 if c >= n else 0
    sub_mod();
  }

#verbatim
}
#endverbatim
