include "../../../arch/riscv/decls.i.vad"

#verbatim
include "../../../arch/riscv/decls.i.dfy"
include "../../../../lib/bv32_ntt_lemmas.i.dfy"

module mq_arith {

import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened integers
import opened bv32_ops
import opened bv32_ntt_lemmas

#endverbatim
    
ghost procedure lemma_mq_add_correct(
    ghost d: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost r: uint32,
    ghost x: nat,
    ghost y: nat,
    ghost Q: int) extern;

ghost procedure lemma_mq_sub_correct(
    ghost d: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost r: uint32,
    ghost x: nat,
    ghost y: nat) extern;

ghost procedure lemma_mq_rshift1_correct(
    ghost par: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost d: uint32,
    ghost r: uint32,
    ghost x: nat) extern;

procedure mq_add(inout dst: reg32, inout src1: reg32, inout src2: reg32, inout mod: reg32) returns (ghost r: uint32)
    requires
        src1 < NTT_PRIME;
        src2 < NTT_PRIME;

        @src1 != @src2;
        @dst != @src2;
        @dst != @mod;
        @mod != @src1;
        @mod != @src2;
    ensures
      r == dst;
      // r == mod(old(src1) + old(src2), NTT_PRIME);
{
    ghost var Q: int := NTT_PRIME;
    ghost var x: nat := src1;
    ghost var y: nat := src2;

    // load -NTT_PRIME into mod
    li(mod, 0xffffcfff);
    assert to_int32(mod) == (-Q);
    let negQ := to_int32(mod);

    // src2 = y - Q
    add(src2, src2, mod);
    assert src2 == uint32_add(to_uint32(y), to_uint32(negQ));

    // src2 = y - Q + x
    add(src2, src2, src1);
    assert src2 == uint32_add(to_uint32(x), uint32_add(to_uint32(y), to_uint32(negQ)));
    ghost var d := src2;

    // lui(mod, 0x3);
    // addi(mod, mod, 1);
    li(mod, 0x3001); // NTT_PRIME
    assert mod == Q;
    assert mod == NTT_PRIME;

    // src2 = d
    // src1 = d >> 31
    srai(src1, src2, 0x1f); // 31
    ghost var b := src1;

    // src1 = (Q & -(d >> 31)) + d
    and(src1, src1, mod);
    
    // c == b & Q
    ghost var c := uint32_and(b, to_uint32(Q));
    assert c == src1;
   
    add(dst, src1, src2);
    r := dst;
    assert r == uint32_add(c, d);
    
    // preconditions for lemma_mq_add_correct
    assert 0 <= x < NTT_PRIME;
    assert 0 <= y < NTT_PRIME;
    assert Q == NTT_PRIME;
    assert d == uint32_add(to_uint32(x), uint32_add(to_uint32(y), to_uint32((-(Q)))));
    assert b == to_uint32(int32_rs(to_int32(d), 31));
    assert c == uint32_and(b, to_uint32(NTT_PRIME));
    assert r == uint32_add(c, d);

    lemma_mq_add_correct(d, b, c, r, x, y, Q);

    assert r == dst;
    assume false;
}
    
// procedure mq_sub(inout dst: reg32, in src1: reg32, in src2: reg32) returns (ghost r: uint32)
//     {:noInline}
//     requires
//         a0 < NTT_PRIME;
//         a1 < NTT_PRIME;
//     modifies
//         dst, src1, src2, m;
//     ensures
//       r == a0;
//       r == mod(old(a0) - old(a1), NTT_PRIME);
// {
//     ghost var Q: int := NTT_PRIME;
//     ghost var x: nat := a0;
//     ghost var y: nat := a1;
//     
//     // a1 == x - y;
//     sub(a1, a0, a1);
//     ghost var d := a1;
//     
//     // lui(a5, 0x3);
//     // addi(a5, a5, 1)
//     li(a5, 0x3001);
//     assert a5 == Q;
// 
//     srai(a0, a1, 0x1f);
//     ghost var b := a0;
// 
//     and(a0, a0, a5);
//     ghost var c := uint32_and(b, to_uint32(Q));
//     assert c == a0;
// 
//     add(a0, a0, a1);
//     r := a0;
//     
//     lemma_mq_sub_correct(d, b, c, r, x, y);
// }
//     
// procedure mq_rshift1() returns (ghost r: uint32)
//     {:noInline}
//     requires
//         a0 < NTT_PRIME;
//     modifies
//         a0; a4; a5;
//     ensures
//         //r == (old(a0) / 2) % NTT_PRIME;
//         r < NTT_PRIME;
//         mod((2 * r), NTT_PRIME) == mod(old(a0), NTT_PRIME);
// {
//     ghost var Q: int := NTT_PRIME;
//     ghost var x: nat := a0;
// 
//     andi(a5, a0, 1);
//     ghost var par := a5; // 1 if x is odd
//     
//     // lui(a4, 0x3);
//     // addi(a4, a4, 1);
//     li(a4, 0x3001); // NTT_PRIME
//     
//     neg(a5, a5); // 0 or 0xffff_ffff
//     ghost var b := a5;
// 
//     and(a5, a5, a4);
//     ghost var c := uint32_and(b, to_uint32(Q));
//     assert c == a5;
// 
//     add(a0, a5, a0);
//     ghost var d := uint32_add(to_uint32(x), c); // x + (Q or 0)
//      
//     srai(a0, a0, 0x1);
//     r := a0;
// 
//     lemma_mq_rshift1_correct(par, b, c, d, r, x);
// }
//     


#verbatim
}
#endverbatim
