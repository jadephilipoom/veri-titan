include "../../../arch/riscv/decls.i.vad"

#verbatim
include "../../../arch/riscv/decls.i.dfy"
include "../../../../lib/falcon/bv32_falcon_lemmas.i.dfy"

module mq_arith {

import opened integers
import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened bv32_ops
import opened bv32_falcon_lemmas
import opened pows_of_2
import opened ntt_polys
import opened nth_root

#endverbatim

type pow2_t: Type(0) extern;
function pow2(exp: int): pow2_t extern;
function operator(.full) (p :pow2_t): nat extern;
function operator(.exp) (p :pow2_t): nat extern;
function pow2_half(p: pow2_t): pow2_t extern;
function pow2_double(p: pow2_t): pow2_t extern;

const N: pow2_t extern;
const R: nat extern;

function rs1_is_half(a: uint32): void extern;

procedure p2_half(inout dst: reg32, ghost p: pow2_t)
    returns (ghost p': pow2_t)
    requires
        dst == p.full;
        p.full >= 2;
    ensures
        dst == old(dst) / 2;
        dst == p'.full;
        p' == pow2_half(p);
{
    srli(dst, dst, 1);
    p' := pow2_half(p);
    rs1_is_half(old(dst));
}

procedure half(inout dst: reg32)
    ensures dst == old(dst) / 2;
{
    srli(dst, dst, 1);
    rs1_is_half(old(dst));
}

function ls1_is_double(a: uint32): void extern;

procedure p2_double(inout dst: reg32, ghost p: pow2_t)
    returns (ghost p': pow2_t)
    requires
        dst == p.full;
        p.full <= 512;
    ensures
        dst == old(dst) * 2;
        dst == p'.full;
        p' == pow2_double(p);
{
    slli(dst, dst, 1);
    p' := pow2_double(p);
    ls1_is_double(old(dst));
}

function montmul(a: nat, b: nat): uint32 extern;
function mqmul(a: nat, b: nat): uint32 extern;
function mqsub(a: nat, b: nat): uint32 extern;
function mqadd(a: nat, b: nat): uint32 extern;

procedure mq_montymul()
    requires
        a0 == 12289;
        a1 < 12289;
        s5 < 12289;
    reads
        s5;
    modifies
        a1; a2; a3; a4;
    
    ensures
        a1 == montmul(old(a1), old(s5));
{
    // mul(a1, s5);
    assume false;
}

procedure mq_sub()
    requires
        a0 == 12289;
        a1 < 12289;
        a2 < 12289;
    reads
        a1; a2;
    modifies
        a3; a4;
    ensures
        a3 == mqsub(old(a2), old(a1));
{
    assume false;
}

procedure mq_add()
    requires
        a0 == 12289;
        a1 < 12289;
        a2 < 12289;
    reads
        a1; a2;
    modifies
        a3; a4;
    ensures
      a3 == mqadd(old(a2), old(a1));
{
    assume false;
}

ghost procedure lemma_mq_add_correct(
    ghost d: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost r: uint32,
    ghost x: nat,
    ghost y: nat) extern;

ghost procedure lemma_mq_sub_correct(
    ghost d: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost r: uint32,
    ghost x: nat,
    ghost y: nat) extern;

ghost procedure lemma_mq_rshift1_correct(
    ghost par: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost d: uint32,
    ghost r: uint32,
    ghost x: nat) extern;

// procedure mq_add() returns (ghost r: uint32)
//     {:noInline}
//     requires
//         a0 < 12289;
//         a1 < 12289;
//     modifies
//         a0; a1; a5;
//     ensures
//       r == a0;
//       r == (old(a0) + old(a1)) % 12289;
// {
//     ghost var Q: int := 12289;
//     ghost var x: nat := a0;
//     ghost var y: nat := a1;

//     // load -12289 into a5
//     li(a5, 0xffffcfff);
//     assert to_int32(a5) == (-Q);
//     let negQ := to_int32(a5);

//     // a1 = y - Q
//     add(a1, a1, a5);
//     assert a1 == uint32_add(to_uint32(y), to_uint32(negQ));

//     // a1 = y - Q + x
//     add(a1, a1, a0);
//     assert a1 == uint32_add(to_uint32(x), uint32_add(to_uint32(y), to_uint32(negQ)));
//     ghost var d := a1;

//     // lui(a5, 0x3);
//     // addi(a5, a5, 1);
//     li(a5, 0x3001); // 12289
//     assert a5 == Q;

//     // a1 = d
//     // a0 = d >> 31
//     srai(a0, a1, 0x1f); // 31
//     ghost var b := a0;

//     // a0 = (Q & -(d >> 31)) + d
//     and(a0, a0, a5);
    
//     // c == b & Q
//     ghost var c := uint32_and(b, to_uint32(Q));
//     assert c == a0;
   
//     add(a0, a0, a1);
//     r := a0;
    
//     lemma_mq_add_correct(d, b, c, r, x, y);
// }
    
// procedure mq_sub() returns (ghost r: uint32)
//     {:noInline}
//     requires
//         a0 < 12289;
//         a1 < 12289;
//     modifies
//         a0; a1; a5;
//     ensures
//       r == a0;
//       r == (old(a0) - old(a1)) % 12289;
// {
//     ghost var Q: int := 12289;
//     ghost var x: nat := a0;
//     ghost var y: nat := a1;
    
//     // a1 == x - y;
//     sub(a1, a0, a1);
//     ghost var d := a1;
    
//     // lui(a5, 0x3);
//     // addi(a5, a5, 1)
//     li(a5, 0x3001);
//     assert a5 == Q;

//     srai(a0, a1, 0x1f);
//     ghost var b := a0;

//     and(a0, a0, a5);
//     ghost var c := uint32_and(b, to_uint32(Q));
//     assert c == a0;

//     add(a0, a0, a1);
//     r := a0;
    
//     lemma_mq_sub_correct(d, b, c, r, x, y);
// }
    
procedure mq_rshift1() returns (ghost r: uint32)
    {:noInline}
    requires
        a0 < 12289;
    modifies
        a0; a4; a5;
    ensures
        //r == (old(a0) / 2) % 12289;
        r < 12289;
        (2 * r) % 12289 == old(a0) % 12289;
{
    ghost var Q: int := 12289;
    ghost var x: nat := a0;

    andi(a5, a0, 1);
    ghost var par := a5; // 1 if x is odd
    
    // lui(a4, 0x3);
    // addi(a4, a4, 1);
    li(a4, 0x3001); // 12289
    
    neg(a5, a5); // 0 or 0xffff_ffff
    ghost var b := a5;

    and(a5, a5, a4);
    ghost var c := uint32_and(b, to_uint32(Q));
    assert c == a5;

    add(a0, a5, a0);
    ghost var d := uint32_add(to_uint32(x), c); // x + (Q or 0)
     
    srai(a0, a0, 0x1);
    r := a0;

    lemma_mq_rshift1_correct(par, b, c, d, r, x);
}
    


#verbatim
}
#endverbatim
