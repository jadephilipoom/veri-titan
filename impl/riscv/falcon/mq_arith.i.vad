include "../../../arch/riscv/decls.i.vad"

#verbatim
include "../../../arch/riscv/decls.i.dfy"
include "../../../../lib/bv32_ntt_lemmas.i.dfy"

module mq_arith {

import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened integers
import opened bv32_ops
import opened bv32_ntt_lemmas

#endverbatim
    
ghost procedure lemma_mq_add_correct(
    ghost d: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost r: uint32,
    ghost x: nat,
    ghost y: nat) extern;

ghost procedure lemma_mq_sub_correct(
    ghost d: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost r: uint32,
    ghost x: nat,
    ghost y: nat) extern;

ghost procedure lemma_mq_rshift1_correct(
    ghost par: uint32,
    ghost b: uint32,
    ghost c: uint32,
    ghost d: uint32,
    ghost r: uint32,
    ghost x: nat) extern;

procedure mq_add() returns (ghost r: uint32)
    {:noInline}
    requires
        a0 < NTT_PRIME;
        a1 < NTT_PRIME;
    modifies
        a0; a1; a5;
    ensures
      r == a0;
      r == mod(old(a0) + old(a1), NTT_PRIME);
{
    ghost var Q: int := NTT_PRIME;
    ghost var x: nat := a0;
    ghost var y: nat := a1;

    // load -NTT_PRIME into a5
    li(a5, 0xffffcfff);
    assert to_int32(a5) == (-Q);
    let negQ := to_int32(a5);

    // a1 = y - Q
    add(a1, a1, a5);
    assert a1 == uint32_add(to_uint32(y), to_uint32(negQ));

    // a1 = y - Q + x
    add(a1, a1, a0);
    assert a1 == uint32_add(to_uint32(x), uint32_add(to_uint32(y), to_uint32(negQ)));
    ghost var d := a1;

    // lui(a5, 0x3);
    // addi(a5, a5, 1);
    li(a5, 0x3001); // NTT_PRIME
    assert a5 == Q;

    // a1 = d
    // a0 = d >> 31
    srai(a0, a1, 0x1f); // 31
    ghost var b := a0;

    // a0 = (Q & -(d >> 31)) + d
    and(a0, a0, a5);
    
    // c == b & Q
    ghost var c := uint32_and(b, to_uint32(Q));
    assert c == a0;
   
    add(a0, a0, a1);
    r := a0;
    
    lemma_mq_add_correct(d, b, c, r, x, y);
}
    
procedure mq_sub() returns (ghost r: uint32)
    {:noInline}
    requires
        a0 < NTT_PRIME;
        a1 < NTT_PRIME;
    modifies
        a0; a1; a5;
    ensures
      r == a0;
      r == mod(old(a0) - old(a1), NTT_PRIME);
{
    ghost var Q: int := NTT_PRIME;
    ghost var x: nat := a0;
    ghost var y: nat := a1;
    
    // a1 == x - y;
    sub(a1, a0, a1);
    ghost var d := a1;
    
    // lui(a5, 0x3);
    // addi(a5, a5, 1)
    li(a5, 0x3001);
    assert a5 == Q;

    srai(a0, a1, 0x1f);
    ghost var b := a0;

    and(a0, a0, a5);
    ghost var c := uint32_and(b, to_uint32(Q));
    assert c == a0;

    add(a0, a0, a1);
    r := a0;
    
    lemma_mq_sub_correct(d, b, c, r, x, y);
}
    
procedure mq_rshift1() returns (ghost r: uint32)
    {:noInline}
    requires
        a0 < NTT_PRIME;
    modifies
        a0; a4; a5;
    ensures
        //r == (old(a0) / 2) % NTT_PRIME;
        r < NTT_PRIME;
        mod((2 * r), NTT_PRIME) == mod(old(a0), NTT_PRIME);
{
    ghost var Q: int := NTT_PRIME;
    ghost var x: nat := a0;

    andi(a5, a0, 1);
    ghost var par := a5; // 1 if x is odd
    
    // lui(a4, 0x3);
    // addi(a4, a4, 1);
    li(a4, 0x3001); // NTT_PRIME
    
    neg(a5, a5); // 0 or 0xffff_ffff
    ghost var b := a5;

    and(a5, a5, a4);
    ghost var c := uint32_and(b, to_uint32(Q));
    assert c == a5;

    add(a0, a5, a0);
    ghost var d := uint32_add(to_uint32(x), c); // x + (Q or 0)
     
    srai(a0, a0, 0x1);
    r := a0;

    lemma_mq_rshift1_correct(par, b, c, d, r, x);
}
    


#verbatim
}
#endverbatim
