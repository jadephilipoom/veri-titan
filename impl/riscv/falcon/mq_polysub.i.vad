include "../../../arch/riscv/decls.i.vad"

#verbatim
include "../../../arch/riscv/decls.i.dfy"
include "../../../../lib/bv32_ntt_lemmas.i.dfy"
include "../../../../lib/bv32_mm_lemmas.i.dfy"

module mq_polysub {

import opened rv_machine
import opened rv_decls
import opened rv_vale
import opened mem

import opened integers
import opened bv32_ops
import opened bv32_mm_lemmas
import opened bv32_ntt_lemmas


ghost procedure poly_sub_correct_lemma(
) extern;    
    
function poly_sub_loop_inv(
) : bool extern;

#endverbatim

procedure poly_sub_save_regs()
    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 16);

    modifies
        sp; mem; flat;
    reads
        ra; s0; s1; s2;
    ensures
        sp == old(sp) - 16;
        mem == stack_push_batch(old(mem), old(flat),
            seq(s2, s1, s0, ra));
        stack_depth(mem) == stack_depth(old(mem)) + 1;
{
    push_frame((-16));
    sw_stack(ra, 12);
    sw_stack(s0, 8);
    sw_stack(s1, 4);
    sw_stack(s2, 0);
}
    let target := stack_push_batch(old(mem), old(flat),
        seq(s2, s1, s0, ra));
    assert top_frame(target.frames) == top_frame(mem.frames);
}
    
procedure poly_sub_loop(ghost iter_f: b16_iter,
    ghost iter_g: b16_iter,
    ghost i: nat)

    returns (ghost iter_f': b16_iter)
    
    requires
        fvar_iter_inv(heap, iter_f, s1, i);
        fvar_iter_inv(heap, iter_g, s0, i);

        iter_f.base_ptr != iter_g.base_ptr;
    
    requires
        s2 == 1024 + iter_g.base_ptr;
    
    ensures
        iter_f'.base_ptr == iter_f.base_ptr;
        fvar_iter_inv(heap, iter_f', s0, i);

        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
    
        poly_sub_loop_inv(iter_a'.buff);
{

    lhu(a1, 0(s0)) // ** load next part of g
    lhu(a0, 0(s1)) // * load next part of f

    addi(s0, s0, 2); // increment g pointer by 16 bytes
    addi(s1, s1, 2); // increment f pointer by 16 bytes

    // jal(ra, 101d8 <mq_sub>)
    mq_sub(); // do subtraction a0 - a1

    sh(a0, -2(s1) // store lower halfword of a0

}
    
/* f' == f - g */
procedure poly_sub(
    ghost iter_f: b16_iter,
    ghost iter_g: b16_iter)

    returns (ghost iter_f': b16_iter)

    modifies
        a0; a1; s0; s1; s2;
        mem; heap;

    ensures
        // forall 0 <= u < n, f'[u] == f[u] - g[u]

{
    // start pre
    // a0 == pointer to f

    poly_sub_save_regs();
    
    li(s0, 0x15b50); // set pointer to g
    // li(a1, 0xc15);   // value of g[0]

    // s1 == pointer to f
    mv(s1, a0);

    // s2 == n == end of s0 + 1024
    addi(s2, s0, 1024);

    // a1 == first value of g
    // s0 == start of g
    // s1 == start of f == a0

    // s2 == s0 + 1024 == end of g

    // end pre

    while (s2 < s1)
    {
        iter_f' := poly_sub_loop(iter_f, iter_g, i);
        i := i + 1;
    }
    
    // post-loop == just stack restoration
    lw(ra, 12(sp)
    lw(s0, 8(sp)
    lw(s1, 4(sp)
    lw(s2, 0(sp)

    addi(sp, sp, 16);
}

        
#verbatim
}
#endverbatim
