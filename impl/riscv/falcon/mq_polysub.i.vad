include "../../../arch/riscv/decls.i.vad"

#verbatim
include "../../../arch/riscv/decls.i.dfy"
include "../../../../lib/bv32_ntt_lemmas.i.dfy"
include "../../../../lib/bv32_mm_lemmas.i.dfy"

module mq_polysub {

import opened rv_machine
import opened rv_decls
import opened rv_vale
import opened mem

import opened integers
import opened bv32_ops
import opened bv32_mm_lemmas
import opened bv32_ntt_lemmas


ghost procedure poly_sub_correct_lemma(
) extern;    
    
function poly_sub_loop_inv(
) : bool extern;

#endverbatim

procedure poly_sub_save_regs()
    requires
        sp == STACK_START();
    modifies
        sp; mem; flat;
    reads
        ra; s0; s1; s2;
    ensures
        sp == STACK_START() - 16;
        mem == stack_push_batch(old(mem), old(flat),
            seq(s2, s1, s0, ra));
        stack_depth(mem) == stack_depth(old(mem)) + 1;
{
    push_frame((-16));
    sw_stack(ra, 12);
    sw_stack(s0, 8);
    sw_stack(s1, 4);
    sw_stack(s2, 0);
}
    let target := stack_push_batch(old(mem), old(flat),
        seq(s2, s1, s0, ra));
    assert top_frame(target.frames) == top_frame(mem.frames);
}
    

procedure poly_sub_loop(ghost i: nat)
    returns 
    
    requires
        iter_safe(iter_f, heap, s0);
        seq_len(iter_f.buff) == 512;
        iter_f.index == 0; 

        iter_safe(iter_g, heap, s1);
        seq_len(iter_g.buff) == 512;
        iter_g.index == 0;

        iter_f.base_ptr != iter_g.base_ptr;
{

    lhu(a1, 0(s0)) // ** load next part of g
    
    lhu(a0, 0(s1) // * load next part of f

    addi(s0, s0, 2); // increment g pointer by 16 bytes
    addi(s1, s1, 2); // increment f pointer by 16 bytes

    // jal(ra, 101d8 <mq_sub>)
    mq_sub(); // do subtraction a0 - a1

    sh(a0, -2(s1) // store lower halfword of a0
    
    bne(s2, s0, 10694 <mq_poly_sub.constprop.0+0x30> // jump to **


}
    
/* f' == f - g */
procedure poly_sub(
    ghost iter_f: iter_t,
    ghost iter_g: iter_t)

    returns (ghost iter_f': iter_t)

    requires
        sp == STACK_START() - 16;


    modifies

    ensures

{
    // at start:
    // a0 == pointer to f

    poly_sub_save_regs();
    
    li(s0, 0x15b50); // set pointer to g
    // li(a1, 0xc15);   // value of g[0] ?

    // s1 == pointer to f
    mv(s1, a0);

    // s2 == n == end of s0 + 1024?
    addi(s2, s0, 1024); // set n

    // a1 == first value of g

    // s0 == loaded const == start of g
    // s1 == a0 == start of f

    // s2 == s0 + 1024 == end of polynomials

    // end pre

    while (s2 != s1)
    {
    
        poly_sub_loop();
    
    }
    


    // post-loop == just stack restoration
    lw(ra, 12(sp)
    lw(s0, 8(sp)
    lw(s1, 4(sp)
    lw(s2, 0(sp)

    addi(sp, sp, 16);
}

        
#verbatim
}
#endverbatim
