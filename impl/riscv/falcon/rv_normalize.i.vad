include "../../../arch/riscv/decls.i.vad"
// include "rv_reg_save.i.vad"

#verbatim

include "../../../arch/riscv/decls.i.dfy"
include "../../../../lib/falcon/bv32_falcon_lemmas.i.dfy"
include "../../../../lib/falcon/normalization_lemmas.i.dfy"

module rv_denormlize {

import opened integers
import opened rv_machine
import opened rv_decls
import opened rv_vale
import opened mem
import opened stack

import opened bv32_ops
import opened bv32_falcon_lemmas
import opened normalization_lemmas

import opened ntt_index
import opened nth_root
import opened poly_view


// import opened rv_reg_save

#endverbatim

function fvar_iter_inv(heap: heap_t, iter: b16_iter, address: int, index: int): bool extern;
function normlized_iter_inv(heap: heap_t, iter: b16_iter, address: int, index: int): bool extern;

procedure denormalize(
    ghost iter_s2: b16_iter,
    ghost iter_tmp: b16_iter)

{:frame false}

    requires
        requires s1 == Q;

        normlized_iter_inv(heap, iter_s2, a1, 0);
        // writable
        fvar_iter_inv(heap, iter_tmp, a3, 0);

        iter_s2.base_ptr != iter_tmp.base_ptr;
{
    addi(t1, a1, 1024);
    ghost var next_iter_s2 := iter_s2;
    ghost var next_iter_tmp := iter_tmp;

    ghost var u :nat := 0;

    while (a1 < t1)
        invariant s1 == Q;
        invariant t1 == iter_s2.base_ptr + 1024;

        invariant next_iter_s2.base_ptr == iter_s2.base_ptr;
        invariant next_iter_s2.buff == iter_s2.buff;
        invariant normlized_iter_inv(heap, next_iter_s2, a1, u);

        // invariant next_iter_tmp.base_ptr == iter_tmp.base_ptr;
        // invariant fvar_iter_inv(heap, next_iter_tmp, a3, u);

        decreases t1 - a1;
    {
        next_iter_s2 := lh_next(t2, a1, 0, true, next_iter_s2);
        srai(t3, t2, 31);
        and(t3, t3, s1);
        add(t2, t2, t3);

        // next_iter_tmp := sh_next(t2, a3, 0, true, next_iter_tmp);

        addi(a3, a3, 2);
        addi(a1, a1, 2);
        u := u + 1;
    }


}

#verbatim
}
#endverbatim