include "../../../arch/riscv/decls.i.vad"
include "mq_arith.i.vad"

#verbatim
include "mq_arith.i.dfy"

module mulntt_ct_std2rev {

import opened integers
import opened rv_machine
import opened rv_decls
import opened rv_vale
import opened mem
import opened stack

import opened bv32_ops
import opened bv32_falcon_lemmas
import opened ntt_model
import opened nth_root
import opened ntt_polys
import opened pows_of_2

#endverbatim

function fvar_iter_inv(heap: heap_t, iter: b16_iter, address: int, index: int): bool extern;

procedure save_s0__r5()
    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 24);

    modifies
        mem; flat; sp;
    reads
        s0; s1; s2; s3; s4; s5;
    ensures
        sp == old(sp) - 24;
        mem == stack_push_batch(old(mem), old(flat),
            seq(s5, s4, s3, s2, s1, s0));
        stack_depth(mem) == stack_depth(old(mem)) + 1;
{
    push_frame((-24));
    sw_stack(s0, 20);
    sw_stack(s1, 16);
    sw_stack(s2, 12);
    sw_stack(s3, 8);
    sw_stack(s4, 4);
    sw_stack(s5, 0);

    let target := stack_push_batch(old(mem), old(flat), seq(s5, s4, s3, s2, s1, s0));
    assert top_frame(target.frames) == top_frame(mem.frames);
}

type pow2_t: Type(0) extern;
function pow2(exp: int): pow2_t extern;
function operator(.full) (p :pow2_t): nat extern;
function operator(.exp) (p :pow2_t): nat extern;
function pow2_half(p: pow2_t): pow2_t extern;
function pow2_double(p: pow2_t): pow2_t extern;

type loop_view: Type(0) extern;
function operator(.hsize) (p :loop_view): pow2_t extern;

function t_loop_inv(a: seq(uint16), d: pow2_t, view: loop_view): bool extern;
function t_loop_end(a: seq(uint16), view: loop_view): bool extern;
function rev_mixed_powers_mont_table(): seq(uint16) extern;
const N: pow2_t extern;
const R: nat extern;

function lsize(view: loop_view): pow2_t extern;

// procedure s_loop(ghost iter_a: b16_iter,
//     ghost iter_p: b16_iter,
//     ghost t: pow2_t,
//     ghost d: pow2_t,
//     ghost j: nat,
//     ghost view: loop_view)
// {

// }

function j_loop_inv(a: seq(uint16), hcount: pow2_t, j: nat, view: loop_view): bool extern;

function rev_mixed_powers_mont_table_lemma(t: pow2_t, d: pow2_t, j: nat): void extern;
function rev_mixed_powers_mont_x_value(i: nat, d: pow2_t): (r: uint16) extern;

function mqmul(a: nat, b: nat): nat extern;

// function LemmaMulIsAssociative(a: nat, b: nat, c: nat) void extern;

procedure j_loop(ghost iter_a: b16_iter,
    ghost iter_p: b16_iter,
    ghost t: pow2_t,
    ghost d: pow2_t,
    ghost j: nat,
    ghost view: loop_view)

    returns (ghost iter_a': b16_iter)

    {:frame false}

    requires
        a0 == 12289; // Q
        a5 == t.full;
        t1 == 0xffffcfff; // -Q
        t6 == d.full;

    requires
        fvar_iter_inv(heap, iter_p, s3, 0);
        fvar_iter_inv(heap, iter_a, s4, 0);
        iter_a.base_ptr != iter_p.base_ptr;

        iter_p.buff == rev_mixed_powers_mont_table();

    requires
        N.full == 512;
        N.exp == 9;
        j_loop_inv(iter_a.buff, d, t2, view);
        t2 < lsize(view).full;
        t == lsize(view);

    ensures
        a0 == old(a0);
        a5 == old(a5);

        s1 == old(s1);
        s3 == old(s3);
        s4 == old(s4);

        t1 == old(t1);
        t2 == old(t2); // j 
        t6 == old(t6);

        iter_a'.base_ptr == iter_a.base_ptr;
        fvar_iter_inv(heap, iter_a', s4, 0);
        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];

    ensures
        ensures j_loop_inv(iter_a'.buff, d, t2 + 1, view);
{
    ghost var j := t2;

    add(s5, a5, t2);
    let sum := t.full + j;
    slli(s5, s5, 1);
    // assume (s5 == sum * 2);
    add(s5, s3, s5);
    // assert s5 == s3 + (t.full + j) * 2;
    // rev_mixed_powers_mont_table_lemma(t, d, t2);

    // let _ := lhu_next(s5, s5, 0, false, iter_p.(index := t.full + j));
    // assert s5 == mqmul(rev_mixed_powers_mont_x_value(2 * j, d), R); // w value

    // mul(t3, t2, t6);
    // assume t3 == t2 * t6;
    // let prod := t3;
    // slli(t3, t3, 1);
    // assume t3 == 2 * prod;

    // assert t3 == 2 * (j * d.full); // s
    // ghost var u := (2 * j) * d.full;
    // assume t3 == u;

    // add(t4, t3, t6);
    // assume t4 == t3 + t6; // u + d.full

    // ghost var bi:nat := 0;

    // while (t3 < t4)
    //     invariant
    //         t4 == u + d.full;
    //         bi == t3 - u; // t3 == s

    //     decreases
    //         t4 - t3;
    // {

    //     bi := bi + 1;
    //     addi(t3, t3, 1);
    // }

    assume false;
}

// function j_loop_inv_pre_lemma(a: seq(uint16), hcount: pow2_t, view: loop_view): void extern;
// function j_loop_inv_post_lemma(a: seq(uint16), hcount: pow2_t, j: nat, view: loop_view):
//     loop_view extern;

// procedure t_loop(ghost iter_a: b16_iter,
//     ghost iter_p: b16_iter,
//     ghost t: pow2_t,
//     ghost d: pow2_t,
//     ghost view: loop_view)
//     returns (ghost iter_a': b16_iter, ghost view': loop_view)

//     {:frame false}

//     requires
//         fvar_iter_inv(heap, iter_p, s3, 0);
//         fvar_iter_inv(heap, iter_a, s4, 0);
//         iter_a.base_ptr != iter_p.base_ptr;

//     requires
//         a0 == 12289; // Q
//         a5 == t.full;
//         t1 == 0xffffcfff; // -Q
//         t6 == d.full;

//         t_loop_inv(iter_a.buff, d, view);
//         t == lsize(view);
//         iter_p.buff == rev_mixed_powers_mont_table();

//     ensures
//         a0 == old(a0);
//         a5 == old(a5);

//         s1 == old(s1);
//         s3 == old(s3);
//         s4 == old(s4);

//         t1 == old(t1);
//         t6 == old(t6);

//         mem == old(mem).(heap := heap);
//         fvar_iter_inv(heap, iter_a', s4, 0);
//         heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
    
//     ensures
//         view.hsize.exp < N.exp ==> t_loop_inv(iter_a'.buff, pow2_half(d), view');
//         view.hsize.exp == N.exp ==> view' == view;
//         view.hsize.exp == N.exp ==> t_loop_end(iter_a'.buff, view');
// {
//     li(t2, 0);
//     iter_a' := iter_a;

//     j_loop_inv_pre_lemma(iter_a'.buff, d, view);

//     while (t2 < a5)
//         invariant
//             a0 == 12289;
//             a5 == t.full;

//             s1 == old(s1);
//             s3 == old(s3);
//             s4 == old(s4);

//             t1 == 0xffffcfff;
//             t6 == d.full;

//         invariant
//             iter_a.base_ptr != iter_p.base_ptr;
//             fvar_iter_inv(heap, iter_p, s3, 0);
//             iter_a'.base_ptr == iter_a.base_ptr;
//             fvar_iter_inv(heap, iter_a', s4, 0);
//             heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
//             mem == old(mem).(heap := heap);

//         invariant
//             j_loop_inv(iter_a'.buff, d, t2, view);

//         decreases
//             a5 - t2;
//     {
//         iter_a' := j_loop(iter_a', iter_p, t, d, t2, view);
//         addi(t2, t2, 1);
//     }

//     view' := j_loop_inv_post_lemma(iter_a'.buff, d, t2, view);
// }

// procedure mulntt_ct_std2rev(
//     ghost iter_a: b16_iter,
//     ghost iter_p: b16_iter,
//     ghost view: loop_view)

//     {:noInline}
//     {:frame false}
    
//     requires
//         in_stack_addr_range(sp);
//         in_stack_addr_range(sp - 24);

//     requires
//         fvar_iter_inv(heap, iter_a, a0, 0);
//         symbols?["ntt512_mixed_powers_rev"];
//         fvar_iter_inv(heap, iter_p,
//             load_symbol(mem, "ntt512_mixed_powers_rev"), 0);
//         iter_a.base_ptr != iter_p.base_ptr;

//     requires
//         N.full == 512;
//         N.exp == 9;

//         t_loop_inv(iter_a.buff, pow2(8), view);
//         iter_p.buff == rev_mixed_powers_mont_table();
// {
//     save_s0__r5();
//     let mem0 := mem;
    
//     ghost var iter_a := iter_a;
//     let a_ptr := iter_a.base_ptr;
//     ghost var view := view;

//     lw_symbol(s3, "ntt512_mixed_powers_rev");

//     mv(s4, a0);

//     li(t1, 0xffffcfff); // -Q
//     li(a0, 12289); // Q

//     li(s1, 9);

//     li(t6, 512); // d 
//     ghost var d := N;
//     assume pow2_half(d) == pow2(8);

//     li(a5, 1); // t 
//     ghost var t := pow2(0);
//     assume t.full == 1;

//     while (s1 > x0)
//         invariant
//             iter_a.base_ptr != iter_p.base_ptr;
//             fvar_iter_inv(heap, iter_a, s4, 0);
//             iter_a.base_ptr == a_ptr;
//             fvar_iter_inv(heap, iter_p, s3, 0);

//             mem == mem0.(heap := heap);
//             heap == old(heap)[a_ptr := heap[a_ptr]];

//         invariant
//             t1 == 0xffffcfff;
//             a0 == 12289;
//             s1 == d.exp;
//             t6 == d.full;
//             a5 == t.full;

//             1 <= d.exp <= N.exp;

//             iter_p.buff == rev_mixed_powers_mont_table();
//             t_loop_inv(iter_a.buff, pow2_half(d), view);
//             t == lsize(view);

//         decreases s1;
//     {
//         srli(t6, t6, 1);
//         d := pow2_half(d);
//         assume d.full == t6;
        
//         iter_a, view := t_loop(iter_a, iter_p, t, d, view);

//         slli(a5, a5, 1);
//         t := pow2_double(t);
//         assume t.full == a5;

//         addi(s1, s1, (-1));
//     }
// }


#verbatim
}
#endverbatim