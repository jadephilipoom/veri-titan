include "../../../arch/riscv/decls.i.vad"
include "mq_arith.i.vad"

#verbatim
include "mq_arith.i.dfy"

module mulntt_ct_std2rev {

import opened integers
import opened rv_machine
import opened rv_decls
import opened rv_vale
import opened mem
import opened stack

import opened bv32_ops
import opened bv32_falcon_lemmas
import opened ntt_model
import opened nth_root
import opened ntt_polys
import opened pows_of_2

import opened mq_arith

#endverbatim

function rev_mixed_powers_mont_table(): seq(uint16) extern;
function rev_mixed_powers_mont_table_lemma(t: pow2_t, d: pow2_t, j: nat): void extern;
function rev_mixed_powers_mont_x_value(i: nat, d: pow2_t): (r: uint16) extern;

type loop_view: Type(0) extern;
function operator(.hsize) (p :loop_view): pow2_t extern;
function lsize(p :loop_view): pow2_t extern;

function fvar_iter_inv(heap: heap_t, iter: b16_iter, address: int, index: int): bool extern;

procedure save_s0__r5()
    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 24);

    modifies
        mem; flat; sp;
    reads
        s0; s1; s2; s3; s4; s5;
    ensures
        sp == old(sp) - 24;
        mem == stack_push_batch(old(mem), old(flat),
            seq(s5, s4, s3, s2, s1, s0));
        stack_depth(mem) == stack_depth(old(mem)) + 1;
{
    push_frame((-24));
    sw_stack(s0, 20);
    sw_stack(s1, 16);
    sw_stack(s2, 12);
    sw_stack(s3, 8);
    sw_stack(s4, 4);
    sw_stack(s5, 0);

    let target := stack_push_batch(old(mem), old(flat), seq(s5, s4, s3, s2, s1, s0));
    assert top_frame(target.frames) == top_frame(mem.frames);
}

function mqmul(a: nat, b: nat): uint32 extern;

function pow2_t_cons(n: nat, exp: nat): pow2_t extern;
function j_loop_inv(a: seq(uint16), hcount: pow2_t, j: nat, u: nat, view: loop_view): bool extern;
function j_loop_inv_pre_lemma(a: seq(uint16), hcount: pow2_t, view: loop_view): void extern;
function j_loop_inv_post_lemma(a: seq(uint16), hcount: pow2_t, j: nat, u: nat, view: loop_view): loop_view extern;

function t_loop_inv(a: seq(uint16), d: pow2_t, view: loop_view): bool extern;
function t_loop_end(a: seq(uint16), view: loop_view): bool extern;

function s_loop_inv(a: seq(uint16), d: pow2_t, j: nat, bi: nat, view: loop_view): bool extern;
function s_loop_inv_pre_lemma(a: seq(uint16), d: pow2_t, j: nat, t: pow2_t, u: nat, ot3:nat, t3: nat, t6: nat, s5: nat, view: loop_view): void extern;
function s_loop_inv_post_lemma(a: seq(uint16), d: pow2_t, j: nat, u: nat, bi: nat, ot3: nat, t3: nat, t6: nat, view: loop_view): void extern;

procedure s_loop(ghost iter_a: b16_iter,
    ghost t: pow2_t,
    ghost d: pow2_t,
    ghost j: nat,
    ghost u: nat,
    ghost bi: nat,
    ghost view: loop_view)

    returns (ghost iter_a': b16_iter)

    {:frame false}

    requires
        a0 == 12289;
        a5 == t.full;

        t1 == 0xffffcfff;
        t2 == j;
        t3 == 2 * u + 2 * d.full;
        t6 == 2 * d.full;

        s2 == 2 * bi + 2 * u;// s

    requires
        fvar_iter_inv(heap, iter_a, s4, 0);
        s_loop_inv(iter_a.buff, d, j, bi, view);
        s5 == mqmul(rev_mixed_powers_mont_x_value(2 * j, d), R);

    ensures
        a0 == old(a0);
        a5 == old(a5);

        s1 == old(s1);
        s2 == old(s2);
        s3 == old(s3);
        s4 == old(s4);
        s5 == old(s5);

        t1 == old(t1);
        t2 == old(t2); // j 
        t3 == old(t3);
        t6 == old(t6);

    ensures
        iter_a'.base_ptr == iter_a.base_ptr;
        fvar_iter_inv(heap, iter_a', s4, 0);
        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
    
    ensures
        s_loop_inv(iter_a'.buff, d, j, bi+1, view);
{
    // add(t4, s4, s2);
    // lhu(dst: reg32, t4, 0, iter_a.(index := ));
    assume false;
}

procedure j_loop(ghost iter_a: b16_iter,
    ghost iter_p: b16_iter,
    ghost t: pow2_t,
    ghost d: pow2_t,
    ghost j: nat,
    ghost u: nat,
    ghost view: loop_view)

    returns (ghost iter_a': b16_iter)

    {:frame false}

    requires
        a0 == 12289; // Q
        a5 == t.full;
        t1 == 0xffffcfff; // -Q
        t2 == j;
        t3 == 2 * u;
        t6 == 2 * d.full;

    requires
        fvar_iter_inv(heap, iter_p, s3, 0);
        fvar_iter_inv(heap, iter_a, s4, 0);
        iter_a.base_ptr != iter_p.base_ptr;

        iter_p.buff == rev_mixed_powers_mont_table();

    requires
        N == pow2_t_cons(512, 9);
        j_loop_inv(iter_a.buff, d, j, u, view);
        t2 < lsize(view).full;
        t == lsize(view);

    ensures
        a0 == old(a0);
        a5 == old(a5);

        s1 == old(s1);
        s3 == old(s3);
        s4 == old(s4);

        t1 == old(t1);
        t2 == old(t2); // j 
        t3 == 2 * (u + 2 * d.full);
        t6 == old(t6);

        iter_a'.base_ptr == iter_a.base_ptr;
        fvar_iter_inv(heap, iter_a', s4, 0);
        mem == old(mem).(heap := heap);
        heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];

    ensures
        ensures j_loop_inv(iter_a'.buff, d, j+1, u + 2 * d.full, view);
{
    iter_a' := iter_a;

    add(s5, a5, t2);
    slli(s5, s5, 1);

    mv(s2, t3); // s2 = 2 * s
    add(t3, t3, t6);

    s_loop_inv_pre_lemma(iter_a'.buff, d, t2, t, u, s2, t3, t6, s5, view);
    add(s5, s5, s3);

    let _ := lhu_next(s5, s5, 0, false, iter_p.(index := t.full + j));
    // assert s5 == mqmul(rev_mixed_powers_mont_x_value(2 * j, d), R); // w 

    ghost var bi:nat := 0;
    assert t3 == 2 * u + 2 * d.full;

    while (s2 < t3)
        invariant
            a0 == 12289;
            a5 == t.full;

            s1 == old(s1);
            s2 == 2 * bi + 2 * u; // s
            s3 == old(s3);
            s4 == old(s4);

            t1 == 0xffffcfff;
            t3 == 2 * u + 2 * d.full;
            t2 == old(t2); // j 
            t6 == 2 * d.full;

        invariant
            fvar_iter_inv(heap, iter_a', s4, 0);
            mem == old(mem).(heap := heap);
            heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
        
        invariant
            s_loop_inv(iter_a'.buff, d, j, bi, view);
            s5 == mqmul(rev_mixed_powers_mont_x_value(2 * j, d), R);

        decreases
            t3 - s2;
    {
        iter_a' := s_loop(iter_a', t, d, j, u, bi, view);
        bi := bi + 1;
        addi(s2, s2, 2);
    }

    let ot3 := t3;
    add(t3, t3, t6);

    s_loop_inv_post_lemma(iter_a'.buff, d, j, u, bi, ot3, t3, t6, view);
}

procedure t_loop(ghost iter_a: b16_iter,
    ghost iter_p: b16_iter,
    ghost t: pow2_t,
    ghost d: pow2_t,
    ghost view: loop_view)
    returns (ghost iter_a': b16_iter, ghost view': loop_view)

    {:frame false}

    requires
        fvar_iter_inv(heap, iter_p, s3, 0);
        fvar_iter_inv(heap, iter_a, s4, 0);
        iter_a.base_ptr != iter_p.base_ptr;

    requires
        N == pow2_t_cons(512, 9);
        a0 == 12289; // Q
        a5 == t.full;
        t1 == 0xffffcfff; // -Q
        t6 == 2 * d.full;

        t_loop_inv(iter_a.buff, d, view);
        t == lsize(view);
        iter_p.buff == rev_mixed_powers_mont_table();

    ensures
        a0 == old(a0);
        a5 == old(a5);

        s1 == old(s1);
        s3 == old(s3);
        s4 == old(s4);

        t1 == old(t1);
        t6 == old(t6);

        mem == old(mem).(heap := heap);
        fvar_iter_inv(heap, iter_a', s4, 0);
        heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
    
    ensures
        view.hsize.exp < N.exp ==> t_loop_inv(iter_a'.buff, pow2_half(d), view');
        view.hsize.exp == N.exp ==> view' == view;
        view.hsize.exp == N.exp ==> t_loop_end(iter_a'.buff, view');
{
    li(t2, 0);
    li(t3, 0);

    ghost var j :nat := 0;
    ghost var u :nat := 0;

    iter_a' := iter_a;

    j_loop_inv_pre_lemma(iter_a'.buff, d, view);

    while (t2 < a5)
        invariant
            a0 == 12289;
            a5 == t.full;

            s1 == old(s1);
            s3 == old(s3);
            s4 == old(s4);

            t1 == 0xffffcfff;
            t2 == j;
            t3 == 2 * u;
            t6 == 2 * d.full;

        invariant
            iter_a.base_ptr != iter_p.base_ptr;
            fvar_iter_inv(heap, iter_p, s3, 0);
            iter_a'.base_ptr == iter_a.base_ptr;
            fvar_iter_inv(heap, iter_a', s4, 0);
            heap == old(heap)[iter_a.base_ptr := heap[iter_a.base_ptr]];
            mem == old(mem).(heap := heap);

        invariant
            j_loop_inv(iter_a'.buff, d, j, u, view);

        decreases
            a5 - t2;
    {
        iter_a' := j_loop(iter_a', iter_p, t, d, j, u, view);
        addi(t2, t2, 1);
        j := j + 1;
        u := u + 2 * d.full;
    }

    view' := j_loop_inv_post_lemma(iter_a'.buff, d, j, u, view);
}

procedure mulntt_ct_std2rev(
    ghost iter_a: b16_iter,
    ghost iter_p: b16_iter,
    ghost view: loop_view)

returns (ghost iter_a': b16_iter, ghost view': loop_view)

    {:noInline}
    {:frame false}
    
    requires
        in_stack_addr_range(sp);
        in_stack_addr_range(sp - 24);

    requires
        fvar_iter_inv(heap, iter_a, a0, 0);
        symbols?["ntt512_mixed_powers_rev"];
        fvar_iter_inv(heap, iter_p,
            load_symbol(mem, "ntt512_mixed_powers_rev"), 0);
        iter_a.base_ptr != iter_p.base_ptr;

    requires
        N == pow2_t_cons(512, 9);
        t_loop_inv(iter_a.buff, pow2(8), view);
        iter_p.buff == rev_mixed_powers_mont_table();
{
    save_s0__r5();

    let mem0 := mem;

    iter_a' := iter_a;
    view' := view;

    lw_symbol(s3, "ntt512_mixed_powers_rev");

    mv(s4, a0);

    li(t1, 0xffffcfff); // -Q
    li(a0, 12289); // Q

    li(s1, 9);

    li(t6, 1024);
    ghost var d := N;

    li(a5, 1); // t 
    ghost var t := pow2(0);
    assume t.full == 1;

    while (s1 > x0)
        invariant
            iter_a'.base_ptr != iter_p.base_ptr;
            fvar_iter_inv(heap, iter_a', s4, 0);
            iter_a'.base_ptr == iter_a.base_ptr;
            fvar_iter_inv(heap, iter_p, s3, 0);

            mem == mem0.(heap := heap);
            heap == old(heap)
                [iter_a'.base_ptr := heap[iter_a'.base_ptr]];

        invariant
            t1 == 0xffffcfff;
            a0 == 12289;
            s1 == d.exp;
            t6 == 2 * d.full;
            a5 == t.full;

            1 <= d.exp <= N.exp;

            iter_p.buff == rev_mixed_powers_mont_table();
            t_loop_inv(iter_a'.buff, pow2_half(d), view');
            t == lsize(view');

        decreases s1;
    {
        half(t6);
        d := pow2_half(d);

        iter_a', view' := t_loop(iter_a', iter_p, t, d, view');

        t := p2_double(a5, t);
        addi(s1, s1, (-1));
    }
}

#verbatim
}
#endverbatim