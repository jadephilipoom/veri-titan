include "../../arch/riscv/decls.i.vad"

#verbatim
include "../../arch/riscv/decls.i.dfy"
include "../../../impl/riscv/ge_mod_lemmas.i.dfy"

module sub_mod {

import opened bv_ops
import opened rsa_ops

import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened ge_mod_lemmas

import opened BASE_32_Seq
import opened Power

#endverbatim

ghost procedure uint32_to_bool(ghost x: uint32) returns (ghost b: bool) extern;    
ghost procedure uint32_to_uint1(ghost x: uint32) returns (ghost i: uint1) extern;    

function ge_mod32_loop_inv(
    iter_a: iter_t,
    iter_n: iter_t,
    cond: uint1,
    b: bool) : bool extern;    

ghost procedure lemma_ge_mod32_correct(
      ghost iter_a: iter_t,
      ghost iter_n: iter_t,
      ghost iter_a_prev: iter_t,
      ghost iter_n_prev: iter_t,
      ghost cond: uint1,
      ghost b: bool,
      ghost i: int
) extern;

procedure ge_mod32(ghost iter_n: iter_t, ghost iter_a: iter_t)
    returns (ghost result: bool)
    requires
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 96;
        iter_n.index == 95; // end of buff

        iter_safe(iter_a, mem, x10);
        seq_len(iter_a.buff) == 96;
        iter_a.index == 95; // end of buff

        iter_n.base_addr != iter_a.base_addr;

        // TODO: should be hard-coded in the semantics
        x0 == 0;
    reads
        x0; mem;
    modifies
        x10; x11; x12; x13; x14; x15;
    ensures
        // iter valid for n
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 96;

        // iter valid for a
        iter_safe(iter_a, mem, x10);
        seq_len(iter_a.buff) == 96;
    
        result == to_nat(iter_a.buff) >= to_nat(iter_n.buff);
  {

    lui(x11, 0x11); // 0x11000 into x11
    assume x11 == 0x11000;

    addi(x15, x11, 1560); // n = 71192 into x15
    assert x15 == 71192;

    addi(x10, x10, 384); // pointer to end of a

    addi(x15, x15, 384); // pointer to end of n
    assert x15 == 71576;
    
    addi(x11, x11, 1560); // pointer to beginning of n
    assert x11 == 71192;
    
    addi(x12, x0, 1); // move 1 into x12 -- x12 = cond

    ghost var iter_a := iter_a;
    ghost var iter_n := iter_n;
    ghost var cond : uint1 := 1;
    ghost var b : bool := true;
    ghost var i: int := 96;
    
    assert ge_mod32_loop_inv(iter_a, iter_n, cond, b);

    ghost var n_ptr := iter_n.base_addr;
    ghost var a_ptr := iter_a.base_addr;

    while (x12 != x0)
    invariant x15 == 71576 - 4 * i;
    invariant x11 == 71192;
    invariant 0 < i <= 96;

    invariant x12 >= 0;
    invariant x0 == 0;

    invariant iter_inv(iter_a, mem, x10);
    invariant iter_a.base_addr == a_ptr;
    invariant iter_a.index == i - 1;
    
    invariant iter_inv(iter_n, mem, x15);
    invariant iter_n.base_addr == n_ptr;
    invariant iter_n.index == i - 1;
    
    invariant ge_mod32_loop_inv(iter_a, iter_n, cond, b);
    decreases loop_ctr;
    {
      let iter_a_prev := lw_prev(x13, x10, 0, iter_a); // x13 = a[i] -- 10148
      let iter_n_prev := lw_prev(x14, x15, 0, iter_n); // x14 = n[i]
    
      ghost var a_i := iter_a.buff[i];
      ghost var n_i := iter_n.buff[i];
      
      addi(x15, x15, (-4)); // x15 = pointer to n[i-1]
      addi(x10, x10, (-4)); // x10 = pointer to a[i-1]

      // if a[i] != n[i]
      sub(x12, x13, x14); // a[i] - n[i]
    
      sltu(x12, x0, x12); // 0 if a[i] - n[i] = 0, else 1
      ghost var neq := uint32_lt(0, uint32_sub(a_i, n_i));

      slt(x13, x0, x12); // 0 if 0 < a[i] - n[i]
      ghost var lt := int32_lt(0, to_int32(uint32_sub(a_i, n_i)));

      xor(x12, x11, x15);
      sltu(x12, x0, x12); // 1 if 0 < x12, 0 if they're equal
      ghost var end := uint32_lt(0, x12);
    
      iter_a := iter_a_prev;
      iter_n := iter_n_prev;
    
      assert(x12 == 0 || x12 == 1);
      cond := uint32_to_uint1(x12);

      assert(x13 == 0 || x13 == 1);
      b := uint32_to_bool(x13);

      lemma_ge_mod32_correct(iter_a, iter_n, iter_a_prev, iter_n_prev, cond, b, i);

      assert(i > 0);
      i := i - 1;
    }
    
    // move b value to expected result register
    mv(x10, x13);
  }


#verbatim
}
#endverbatim
