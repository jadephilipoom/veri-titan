include "../../arch/riscv/decls.i.vad"

#verbatim
include "../../arch/riscv/decls.i.dfy"
include "../../../lib/bv32_mm_lemmas.i.dfy"

module ge_mod {

import opened integers
import opened rv_machine
import opened rv_decls
import opened rv_vale

import opened bv32_mm_lemmas

#endverbatim

ghost procedure lemma_ge_mod_correct(
    ghost a: seq(uint32),
    ghost n: seq(uint32),
    ghost j: int,
    ghost result: uint32) extern; 

procedure ge_mod(ghost iter_n: iter_t, ghost iter_a: iter_t)
    returns (ghost result: bool)
    requires
        iter_safe(iter_n, mem, 71192);
        seq_len(iter_n.buff) == 96;
        iter_n.index == 0;

        iter_safe(iter_a, mem, a0);
        seq_len(iter_a.buff) == 96;
        iter_a.index == 0;

    reads
        x0; mem;
    modifies
        a0; a1; a2; a3; a4; a5;
    ensures
      result == (a0 == 0);
      a0 != 0 ==> to_nat(iter_a.buff) < to_nat(iter_n.buff);
      a0 == 0 ==> to_nat(iter_a.buff) >= to_nat(iter_n.buff);
{
    assume false;
    // lui(a1, 0x11); // 0a1000 into a1
    // assume 0x11000 == a1;

    // addi(a5, a1, 1560); // n = 71192 into a5

    // addi(a0, a0, 380); // pointer to end of a
    // ghost var iter_a := iter_a.(index := 95);
    // // assert iter_safe(iter_a, mem, a0);

    // addi(a5, a5, 380); // pointer to end of n
    // ghost var iter_n := iter_n.(index := 95);
    // // assert iter_safe(iter_n, mem, a5);

    // addi(a1, a1, 1560); // pointer to beginning of n
    // // assert a1 == 71192;

    // addi(a2, x0, 1); // move 1 into a2 -- a2 = cond

    // ghost var i: int := 95;
    // ghost var a_ptr := iter_a.base_addr;
    // ghost var a := iter_a.buff;
    // ghost var n := iter_n.buff;
  
    // while (a2 != x0)
    //   invariant x0 == 0;
    //   invariant iter_n.base_addr == a1;
    //   invariant iter_n.buff == n;
    //   invariant iter_a.base_addr == a_ptr;
    //   invariant iter_a.buff == a;
    //   invariant (a2 != x0) ==> 
    //     (iter_inv(iter_n, mem, a5) &&
    //     iter_n.index == i &&
    //     iter_inv(iter_a, mem, a0) &&
    //     iter_a.index == i);
    //   invariant seq_len(iter_n.buff) == 96;
    //   invariant seq_len(iter_a.buff) == 96;

    //   invariant a2 != 0 ==> 0 <= i <= 95;
    //   invariant a2 != 0 ==> (a[i+1..] == n[i+1..]);
    //   invariant a2 == 0 ==> (-1) <= i < 95;
    //   invariant a2 == 0 ==> (a[i+2..] == n[i+2..]);
    //   invariant a2 == 0 ==> (a[i+1] != n[i+1] || i == (-1));
    //   invariant a2 == 0 ==> (a3 != 0 <==> a[i+1] < n[i+1]);
    //   invariant (a2 == 0 && i != (-1)) ==> (a3 == 0 ==> a[i+1] > n[i+1]);
    //   invariant (a2 == 0 && i == (-1)) ==> (a3 == 0 ==> a[i+1] >= n[i+1]);
    //   decreases i;
    // {
    //   let iter_a_prev := lw_prev(a3, a0, 0, iter_a); // a3 = a[i]
    //   // let a_i := a[i];

    //   let iter_n_prev := lw_prev(a4, a5, 0, iter_n); // a4 = n[i]
    //   // let n_i := n[i];

    //   sub(a2, a3, a4);
    //   sltu(a3, a3, a4);
    //   sltu(a4, x0, a2);
    //   xor(a2, a1, a5);

    //   if (a4 != x0) {
    //     add(a2, x0, x0);
    //   }

    //   addi(a0, a0, (-4));  
    //   addi(a5, a5, (-4));

    //   iter_a := iter_a_prev;
    //   iter_n := iter_n_prev;

    //   i := i - 1;
    // }

    // mv(a0, a3);
    // lemma_ge_mod_correct(a, n, i+1, a0);

    // result := if a0 == 0 then true else false;
}

#verbatim
}
#endverbatim
