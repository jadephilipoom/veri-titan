include "../../arch/otbn/decls.i.vad"

#verbatim

include "../../arch/otbn/decls.i.dfy"
include "../../../lib/bv256_mm_lemmas.s.dfy"

module addc512 {

import opened ot_machine
import opened ot_abstraction
import opened ot_decls
import opened ot_vale

import opened integers
import opened bv256_mm_lemmas

#endverbatim

function dw_add_is_safe(x_lh: int, x_uh: int, y_lh: int, y_uh: int): bool extern;

function dw_add_lemma(x_lh: int, x_uh: int,
    y_lh: int, y_uh: int, c1: uint1, c2: uint1, z_lh: int, z_uh: int): uint512_view_t extern;

procedure seq_addc_512_safe(
    inout dst1: reg256, in src1a: reg256, in src1b: reg256,
    inout dst2: reg256, in src2a: reg256, in src2b: reg256)
    returns (ghost sum: uint512_view_t)

    requires
        dw_add_is_safe(src1a, src2a, src1b, src2b);
        src2b == 0;

        is_wide_data_register(@dst1);
        is_wide_data_register(@dst2);

        @dst1 != @dst2;
        @dst1 != @src2a;
        @dst1 != @src2b;

    reads
        wdrs;

    modifies
        fgroups;

    ensures
        sum.full == to_nat(seq(old(src1a), old(src2a))) + old(src1b);
        valid_uint512_view(wdrs, sum, @dst1.index, @dst2.index);
{
    ghost var x_lh := src1a;
    ghost var y_lh := src1b;
    ghost var x_uh := src2a;
    ghost var y_uh := src2b;

    bn_add(dst1, src1a, src1b, SFT_DFT, 0);
    ghost var c1 := bool_to_uint1(fgroups.fg0.cf);
    bn_addc(dst2, src2a, src2b, SFT_DFT, 0);
    ghost var c2 := bool_to_uint1(fgroups.fg0.cf);

    sum := dw_add_lemma(x_lh, x_uh, y_lh, y_uh, c1, c2, dst1, dst2);
}

#verbatim
}
#endverbatim